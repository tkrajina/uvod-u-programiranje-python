\chapter*{Uvod}
\addcontentsline{toc}{chapter}{Uvod}

Kad su se prije dvadesetak godina po캜ela pojavljivati prva osobna ra캜unala, ona
su bila bitno druk캜ija od dana코njih -- rad na njima nije bio toliko intuitivan i
jednostavan kao 코to je rad s dana코njim ra캜unalima. Ipak ljudima koji su tada
bili djeca doti캜na ra캜unala predstavljala izazov, a mnogi dana코nji
inzinjeri i znanstvenici su u to vrijeme po캜eli eksperimentiranje s naredbama
programskih jezika koji su im bili na raspolaganju. Veliki dio tih malih "hakera" je s
vremenom postalo informati캜arima, ali i oni koji to nisu sigurno svoj uspjeh u
znanosti duguju iskustvima s programiranjem, jer programiranje razvija nekoliko
izuzetno vaznih sposobnosti:

\begin{itemize}
   \item sposobnost egzaktnog i logi캜kog razmi코ljanja,
   \item matemati캜ku intuiciju,
   \item vizualnu predodzbu problema i
   \item sposobnost kreiranja matemati캜kog modela za problem pred koji smo
   posta\-vlje\-ni.
\end{itemize}

Danas ra캜unala nisu egzoti캜ne sprave koje si mogu dopustiti samo oni
najimu캖niji, ali postoji jedan veliki problem.
Ra캜unala su danas dovoljno intuitivna i jednostavna za kori코tenje da u stvari ne
nude neki veliki izazov nadarenima. To ne zna캜i da ih oni ne koriste, ali
pitanje je koliko ih kreativno koriste? Internet je danas \emph{in}, ali ako ga ljudi
koriste za \emph{chat}-anje ili trazenje informacija o omiljenoj grupi mozemo se
pitati iskori코tavaju li oni tu mogu\'cnost koliko mogu? Programiranje koje je nekad
bilo izazov danas je to prestalo biti jer programski jezici s kojima se oni susre캖u
u nisu toliko jaki da bi oni mogli raditi programe koji bi barem izgledom sli캜ili
onima koji se besplatno dobiju na CD-ovima raznih informati캜kih 캜asopisa.

Ovom knjizicom (skriptom, knjizuljkom) namjera mi je one mla캠e (i koji se
tako osje캖aju)
uvesti u svijet programiranja. 

Prije svega napomenuo bih da "nau캜iti programirati" uop캖e nije jednostavno.
Moje je iskustvo da dobar programer moze biti samo osoba koja je dovoljno
inteligentna (u matemati캜ko-logi캜kom smislu). Proces u캜enja programiranja
je dug i naporan. Biti 캖ete bombardirani hrpom 캜injenica od kojih ne캖e sve
biti toliko vazne da ih morate pamtiti napamet (ali mogu캖e je da 캖e vam
prije ili kasnije trebati). Jedan od tezih zadataka u cijelom tom procesu je i
sposobnost da znate prepoznate ono 코to je bitno od onog 코to nije.
Kad i ako jednog dana uspijete savladati neki programski jezik to 캖e vam
sigurno predstavljati veliko zadovoljstvo.

\section*{Kako se u캜i programirati?}
\addcontentsline{toc}{section}{Kako se u캜i programirati?}

	"Nau캜iti programirati" je dug i naporan proces koji traje godinama i nikad ne
	prestaje. Ne코to jednostavnije je "nau캜iti odre캠eni programski jezik",
	ali nije dovoljno. Kad i ako nau캜ite programirati uprogramskom jeziku Python,
	jo코 niste niti blizu tome da se mozete smatrati dobrim programerom.

	Da bi postali dobar programer morate:
	\begin{itemize}
		\item puno vjezbati; rje코avati razne programerske probleme, 
			poku코avati na캖i uvijek bolja rje코enja,
		\item nau캜iti nekoliko programskih jezika (코to vi코e to bolje). 
			Kad savladate 3-4 programska jezika otkriti 캖ete da novi programski
			jezici nisu niti otprilike onoliko te코ki koliko je to bilo na
			po캜etku.
		\item 캜itati knjige i prou캜avati programe iskusnih programera
		\item stvoriti na캜in matemati캜ko-logi캜ki na캜in razmi코ljanja
			razmi코ljanja za rje코avanje raznih problema
		\item \dots i za kraj; morate imati \emph{strast} za programiranjem. Ako vam se
			ikad desi da pi코ete neki program i nai캠ete naproblem kojeg ne znate
			rije코iti. Promatrajte sebe; Kako reagirate u tom trenutku? Ako odmah
			odustajete, onda ovo nije za vas. Ako ste uporni i provodite sate, dane 
			poku코avaju캖i na캖i izlaz ili gre코ku u nekom va코em programu
			onda je ovo pravi izazov za vas!
	\end{itemize}

\section*{Za코to Python?}
\addcontentsline{toc}{section}{Za코to Python}

	Ovih nekoliko redova je namijenjeno ljudima koji smatraju da je najbolji programski
	jezik za po캜eti u캜iti programiranje Pascal, BASIC, Logo ili C.

	Dakle, Python zato jer\dots

	\begin{itemize}
		\item Python ima 캜istu sintaksu koja programera prisiljava da pi코e
			pregledne programe (za razliku od kripti캜ne sintakse programskog jezika
			C)
		\item je Python zivi programski jezik kojeg programeri koriste i koji 캖e
			se sve vi코e koristiti (za razliku od BASIC-a i Logo-a)
		\item Pythonova stroga sintakti캜ka pravila programera \emph{prisiljavaju} na
			neke vrlo dobre programerske navike (za razliku od BASIC-a)
		\item je Python objektno objektno orijentiran, pa se za u캜enje OO programiranja
			moze koristiti isti jezik, a ne u캜iti jedan za strukturalno, a jedan
			za OO programiranje (za razliku od BASIC-a i C-a)
		\item se u Pythonu, iako je zami코ljen kao OO jezik bez problema mogu pisati 
			programi koji nemaju niti traga objektnom programiranju (za razliku od Jave)
		\item je Python besplatan i dostupan na skoro svim platformama koje vam padaju
			na pamet
	\end{itemize}
\chapter{O programiranju, programskim jezicima i programima}

\section{O programiranju}

	Program je skup naredbi pomo캖u kojih ra캜unalu poku코avamo objasniti kako
	da rije코ava neki problem.

	Dakle, program pi코emo kad treba rije코iti neki
	problem. Moze se raditi o nekom
	svakodnevnom problemu (napisati program koji 캖e nam pamtiti brojeve telefona),
	nekom matemati캜kom ili logi캜kom zadatku (napisati program
	koji zbraja kvadrate brojeva od 1 do 100000)\dots Ra캜unalo samo, ne zna
	rje코avati probleme, netko treba prije svega na코 problem prevesti na 
	ra캜unalu razumljiv jezik.

	Program po캜injemo pisati kad \emph{znamo} kako 캖emo neki problem
	rije코iti, ali nemam dovoljno vremena da to rije코avamo na neki klasi캜an
	na캜in. Na primjer, zamislite da vam u jednom trenutku treba podatak je li
	71283789238881999511\footnote{Broj je prost ako je djeljiv samo s 1 i sa samim sobom} prost broj ili nije. Prije nego li se uhvatite za glavu moramo
	se sloziti da postoji nekoliko vrsta problema:

	\begin{itemize}
		\item[\emph{(a)}] Problem kod kojeg znamo postupak kako do캖i do rje코enja i
			mozemo jednostavno do캖i do tog rije코enja.
		\item[\emph{(b)}] Problemi kod kojih znamo postupak kako do캖i do 
			rije코enja, ali zbog
			nekog razloga nije tako jednostavno do캖i do rije코enja.
		\item[\emph{(c)}] Problemi kod kojih (jo코) ne znamo postupak do rije코enja.
	\end{itemize}

	Tako bi recimo sljede캖i zadatak "Na캠i peto slovo abecede" sigurno spadao u 
	probleme pod \emph{(a)}, i bilo bi besmisleno pisati program i tjerati ra캜unalo
	da rje코ava jedan tako jednostavan problem. Pitanje prostosti broja 
	71283789238881999511 spada u \emph{(b)}, jer \emph{znamo kako} ispitati je li neki
	broj prost ili nije. Prvo treba provjeriti djeljivost s $2$, pa s $3$, pa s
	$5$\dots Ako ispadne da na코 broj nije djeljiv s ni캜im drugim osim s $1$ i
	sa samim sobom onda jest prost. 

	Postupak je smije코no jednostavan,\footnote{\dots u stvari i nije. Ima tu puno sitnica kako se taj postupak moze
	jo코 vi코e ubrzati.}
	ali pitanje je koliko dugo vremena nam treba
	da zavr코imo. 

	Evo i primjer problema koji moze spadati u skupinu \emph{(c)}: "Pomo캖u
	brojeva 3, 3, 7, 7 i koriste캖i elementarne ra캜unske operacije trebate
	dobiti broj 24". Sad bi trebalo napisati program s kojim 캖e ra캜unalo samo
	rije코iti taj problem.

\section{O programskim jezicima}

	Znati postupak za rije코avanje nekog problema nije garancija da 캖emo taj
	problem i rije코iti. 
	캛ak i ako budem ikada imao dovoljno vremena da ispitam je li broj
	71283789238881999511 
	prost nitko mi ne moze garantirati da ne캖u negdje
	pogrije코iti u ra캜unu ili, ako radim s kalkulatorom -- da ne캖u negdje
	pogre코no utipkati broj.
	Htio bih, zato, da taj posao ra캜unalo obavi umjesto mene.
	
	Problem je u tome 코to ra캜unalo ne govori moj jezik. 
	Mogao bih se do besvjesti truditi mom PC-ju obja코njavati kako sam ja 
	zami코ljao da se rije코i neki problem. 

	Ra캜unala razumiju samo jedan jezik -- \emph{ma코inski jezik}. Naredbe tog
	jezika se sastoje od nula i jedinica (poznati binarni brojevni sustav), a pisanje
	programa u ma코inskom jeziku je sve samo ne jednostavno.

	Zato koristimo neke druge programske jezike koji se onda prevode u 
	ra캜unalu razumljiv ma코inski jezik. 
	Postoje stotine programskih jezika. Nabrojati
	캖u samo neke od popularnijih: Python, C, C++, Java, Pascal, Lisp, Fortran, 
	Perl, Forth, PHP, JavaScript, BASIC, Smalltalk, Ada\dots Neki od tih jezika su
	\emph{interpreteri}, neki \emph{kompajleri}. Neki su \emph{objektno orijentirani},
	neki \emph{strukturalni}. Neki su \emph{komercijalni}, neki su \emph{open source},
	ali svi oni imaju neke sli캜ne osobine: svi oni koriste \emph{varijable},
	\emph{potprograme}, \emph{naredbe grananje}, razne \emph{kontrolne strukture} i
	tako dalje i tako blize\dots Kada dobro savladate jedan programski
	jezik ne캖e vam predstavljati velik problem savladati mnoge druge.

	O svim ovim terminima 캖e se na캖i pone코to u ovoj knjizici, ali dva
	su izuzetno bitna pa 캖u ih objasniti odmah:

\subsection{Interpreteri i kompajleri}

	Ve캖 spomenuh da ra캜unalo razumije samo ma코inski jezik. Kako onda
	ra캜unalo moze shvatiti naredbe bilo kojeg od gore nabrojanih jezika?
	Odgovor je jednostavan, niz naredbi u nekom programskom jeziku se \emph{prevode} na
	ma코inski jezik. 

	Zamislite da vam netko tko govori \emph{Swahili}\footnote{\emph{Swahili}
	je jedan od jezika koji se govore u Zanzibaru. Pretpostavka je da prosje캜ni
	캜itatelj ove knjizice ne razumije Swahili} Zeli re캖i sljede캖e:
	\emph{"Otvori knjigu X na stranici 137. pro캜itaj prvu rije캜 u petom retku.
	Ako ta rije캜 po캜inje suglasnikom odi u kuhinju i skuhaj ru캜ak, a ako
	po캜inje samoglasnikom -- idi se pro코e캖i i pusti me na miru"}.
	Govornik Swahilija se nalazi u situaciji u kojoj se nalazi programer, a vi glumite
	ra캜unalo koje poku코ava shvatiti 코ta vam ovaj ima za kazati. 
	
	Postoji, naravno i prevoditelj. Prevoditelj moze prevoditi simultano ili
	prevesti cijelu poruku odjednom, a vi 캖ete onda to pro캜itati i slijediti
	upute. 

	Ako se prevodi simultano cijela stvar izgleda otprilike ovako ("Sw" je govornik
	Swahilija, "V" ste vi, "V" je prevoditelj):

	\begin{itemize}
		\item[\textbf{Sw:}] ".... .... .... ..... ..... ... .... ..... .... .... ....."\footnote{Zamislite da je ovdje neka re캜enica na jeziku Swahili}
		\item[\textbf{P:}] "Sw je rekao da treba코 otvoriti knjigu X"
		\item[\textbf{V:}] (otvarate knjigu X)
		\item[\textbf{Sw:}] "..... .... .... .... 137. ....."
		\item[\textbf{P:}] "Sw kaze da otvori코 stranicu 137."
		\item[\textbf{V:}] (otvarate knjigu 137.)
		\item[\textbf{Sw:}] "..... . .... ....  ....."
		\item[\textbf{P:}] "Sw kaze da na캠e코 prvu rije캜 u petom retku."
		\item[\textbf{V:}] (trazite prvu rije캜 u petom retku)
		\item[\textbf{Sw:}] "... ....  ....."
		\item[\textbf{P:}] "Sw kaze da pogleda코 prvo slovo te rije캜i"
		\item[\textbf{V:}] (OK, prvo slovo te rije캜i je "r")
		\item[\textbf{Sw:}] "...  ... ... ....  ....."
		\item[\textbf{P:}] "Sw kaze; odi skuhati ru캜ak, ako je to slovo samoglasnik"
		\item[\textbf{V:}] (nije samoglasnik)
		\item[\textbf{Sw:}] "...  ... ... ......  .. ...!"
		\item[\textbf{P:}] "Sw kaze da je najbolje da ode코 u 코etnju"
		\item[\textbf{V:}] (odlazite u 코etnju\dots Bilo je i vrijeme da vas puste na miru!)
	\end{itemize}

	Ovako funkcioniraju programski jezici \emph{interpreteri} -- 캜itaju naredbu
	programa kojeg ste vi napisali, prevedu ju na ma코inski jezik, a ra캜unalo to
	onda izvr코ava, nakon toga pro캜itaju sljede캖u naredbu, prevedu,
	ra캜unalo izvr코ava, pro캜itaju, prevedu, ra캜unalo izvr코ava\dots

	Drugi na캜in je da prevodioc cijelu poruku poslu코a do kraja, prevede ju
	na vama razumljiv jezik, a vi to onda idete izvr코avati. Programski jezici
	kompajleri rade upravo to -- pro캜itaju cijeli va코 program, prevedu na
	ma코inski jezik, a ra캜unalo onda izvr코i program kojeg sada
	ima u obliku kojeg razumije.

	Da bi izvr코ili program u programskom jeziku koji se interpretira morate uvijek
	imati interpreter (prevodilac) ve캖 instaliran na svom ra캜unalu. Kod
	izvr코avanja kompajliranog programa dovoljno je da program jednom kompajlirate,
	odmah dobijete program u obliku kojeg ra캜unalo razumije, a mo캖i 캖ete ga
	pokrenuti na nekom drugom ra캜unalu (na kojem taj programski jezik "nije
	instaliran"). 

	Ako na ra캜unalu imate program koji je prethodno kompajliran ne캖ete mo캖i
	vidjeti kako taj program izgleda, jer on je u memoriji sa캜uvan u ma코inskom
	jeziku (a kojeg vjerojatno ne razumijete, kao Swahili uostalom, jelte 
	:-)\footnote{Ako lutate bespu캖ima interneta onda znate 코ta ova
	dvoto캜ka-crtica-zagrada zna캜e, ako vam je surfanje nepoznanica, onda
	pogledajte taj niz znakova tako da ukosite glavu ulijevo. Uz malo truda trebali
	biste vidjeti nasmijano lice}. 
	S druge
	strane, ako u memoriji imate program u nekom od interpretiranih programskih jezika,
	mo캖i 캖ete slobodno pogledati kako taj program izgleda (editirati kao tekst
	datoteku). Mo캖i 캖ete ga pokrenuti ako i samo ako imate instaliran i
	interpreter-prevodioc za upravo taj programski jezik.

	I, jo코 samo ovo. Razlika izme캠u programskih jezika koji se interpretiraju
	i onih koji se kompajliraju nije to캜no odre캠ena. Postoje, naime programski
	jezici koji se mogu pokretati i interpreterom, a mogu se i kompajlirati. Jo코
	jedna komplikacija su programski jezici koji se kompajliraju, ali ne u ma코inski
	jezik nego u ne코to 코to razumije samo poseban program koji to onda
	interpretira\dots Zaboravite, prezivjeti 캖ete 캜ak i ako ne shvatite sve
	ove tehnikalije.

\section{O programima}
	
	Program je niz naredbi koji opisuje kako se moze rije코iti neki problem. Taj
	niz naredbi mora \emph{to캜no} i \underline{vrlo detaljno} opisati taj
	postupak. Zamislite da nekom stroju morate opisati kako se jede za ru캜kom.
	Izgleda vrlo jednostavno, ipak -- razmislite malo koliko tu ima detalja. Kao prvo
	morate sjesti za stol, ali i to ne mozete bez da prethodno ne odmaknete stolicu
	od stola. Kad sjednete, stolicu treba opet pribliziti stolu. OK, idemo na juhu:
	imate zlicu, grabite u tanjur i stavljate u usta. Opet! Jeste li sigurno da je
	juha uop캖e na tanjuru, ako nije trebate opisati kako staviti juhu u tanjur.
	Zlicom, jel? Hm, jeste li sigurni da ste to캜no opisali kako se zlicom
	stavlja juha, jer ako zlicu ne drzite pod pravim kutom juha 캖e
	se proliti iz zlice. A jo코 nismo niti po캜eli s jelom. Zamislite
	koliko komplicirano moze biti ako morate obja코njavati neki specijalitet od
	ribe kao drugo jelo.
	Tko bi imao volje stroju obja코njavati kako se
	캜iste riblje kosti?

	\subsection{Primjeri u raznim programskim jezicima}

	OK, uspio sam vas obeshrabriti\dots Molim? Nisam? Hhhmmm\dots Ajmo onda probati
	ovako: slijedi nekoliko programa u razli캜itim programskim jezicima koji rade
	jednu te istu stvar:

	\source{Pascal:}{
		program trlababalan;\\
		integer x;\\
		begin\\
		\hspace*{10mm}x := 5;\\
		\hspace*{10mm}if x $=$ 10 then\\
		\hspace*{20mm}writeln( "x je jednako 10" );\\
		\hspace*{10mm}else\\
		\hspace*{20mm}writeln( "x nije jednako 10" );\\
		end.
	}

	Ili, recimo ovako:

	\source{Perl:}{
		x = 5;\\
		if( x == 10 ) \{\\
		\hspace*{10mm}print "x je jednako 10$\setminus$n";\\
		\}\\
		else \{\\
		\hspace*{10mm}print "x nije jednako 10$\setminus$n";\\
		\}
	}

	캛esto je u istom programskom jeziku mogu캖e isti problem rije코iti na
	razli캜ite na캜ine, a programski jezik Perl je posebno poznat po tome. 
	Ovaj gornji program캜i캖 iskusan programer bi napisao ovako:

	\source{Perl:}{
		x = 5;\\
		print x $==$ 10 ? "x je manji od 10$\setminus$n" : "x je ve캖i od 10$\setminus$n";
		}

	U Pythonu bi to izgledalo:

	\source{Python:}{
		x = 5;\\
		if x $<$ 10:\\
		\hspace*{10mm}print "x je manje od 10"\\
		else:\\
		\hspace*{10mm}print "x je ve캖e od 10"
	}
	
	U programskom jeziku Java:

	\source{Java:}{
		public class trlababalan \{\\
		\hspace*{10mm}public static void main( String[] args ) \{\\
		\hspace*{20mm}int x = 5;\\
		\hspace*{20mm}if( x == 10 ) \{\\
		\hspace*{30mm}System.out.println( "x je jednako 10" );\\
		\hspace*{20mm}\}\\
		\hspace*{20mm}else \{\\
		\hspace*{30mm}System.out.println( "x nije jednako 10" );\\
		\hspace*{20mm}\}\\
		\hspace*{10mm}\}\\
		\}
	}
	
	U programskomjeziku HP48 kalkulatora:

	\source{hp48:}{
		$<<$ 5 'x' STO x 10 IF == THEN "x je jednako 10" ELSE "x nije jednako 10" END
		MSGBOX $>>$
	}
	

	Vjerujem da ste uo캜ili neke sli캜nosti u ovim kratkim program캜i캖ima.
	Nemojte dopustiti vas ono 코to ne razumijete obeshrabri. Toga 캖e uvijek
	biti -- na veliku zalost onih koji brzo odustaju, a na zadovoljstvo onima koji
	je "nepoznato" samo jo코 jedan izazov.

\section{O programskom jeziku \emph{Python}}

	Python je programski jezik kojeg je stvorio/kreirao/dizajnirao/smislio Guido Van
	Rossum. Za razliku od komercijalnih programskih jezika, Guido je odlu캜io da
	njegov programski jezik mora biti svima dostupan. I, ne samo da 캖e biti svima
	dostupan nego nego programeri sami mogu mijenjati doti캜ni jezik prema svojim
	potrebama. S vremenom se stvorila grupa ljudi koji su po캜eli pisati programe u
	tom jeziku, a ako im se svi캠ala neka sitnica iz nekog drugog jezika jednostavno
	bi i nju dodali Pythonu.

	Python je interpretirani (ali ne ba코 u smislu "simultanog prevo캠enja") i
	objektno orijentirani (ali bez problema mogu se pisati strukturalni programi)
	programski jezik. Zbog svoje vrlo 캜iste i stroge sintakse je vrlo pogodan da
	bude "prvi programski jezik" ne-programerima. 캛esto je ulogu programskog jezika
	za u캜enje naj캜e코캖e imao BASIC, Pascal, Logo i razni drugi jezici. 
	Well\dots Ne캖u u detalje, ali Python je bolji od njih :-)

	Python je i besplatan, a moze se pokrenuti na skoro svakom ra캜unalu koje
	vam padne na pamet (osim onih \emph{stvarno} prastarih). Ukoliko zelite
	nastaviti 캜itanje ove knjige pozeljno bi bilo da s internet adrese
	http://www.python.org/ skinete Python interpreter i instalirate ga na svom
	ra캜unalu.

\subsection{"Python kao Monty Python?"}

	\emph{"Python kao Monty Python?"} -- Da, \emph{Python} kao \emph{Monty Python}. Da
	citiram "Python tutorial" (za one koji razumiju engleski):

	\begin{quote}
	By the way, the language is named after the BBC show ``Monty Python's
	Flying Circus'' and has nothing to do with nasty reptiles.  Making
	references to Monty Python skits in documentation is not only allowed,
	it is encouraged!
	\end{quote}

\chapter{Uvod u programiranje}

\section{Sto je danas lijep i sun캜an dan}

Kad savladate nekoliko programskih jezika uo캜iti 캖ete
nekoliko pravilnosti koje se pojavljuju kod svih njih. Svi oni
koriste varijable, potprograme, dobar dio njih koristi objekte. Ne
samo to, nego u svim priru캜nicima za programiranje prvi program
ima naziv "Hello world"\footnote{eng.  Zdravo svijete}.

Budu캖i da autor ovog spisa nije nimalo revolucionaran tip, i
mi 캖emo zapo캜eti Zdravo-svijetom\footnote{\hspace*{2mm}"Hello
world"}.  Daklem. "Hello world" u Pythonu izgleda ovako:

	\sourcee{
		\wrd{print} "Hello world"
	}

\textbf{Komentar:} Druga linija je ono 코to je bitno u ovom
programu. Ona kaze prevoditelju-interpreteru da ispi코e na
monitor niz znakova "Hello world" (bez navodnika, navodnici samo
sluze da se zna gdje po캜inje i gdje zavr코ava ono 코to
zelimo ispisati).

\subsection{Snimanje programa}

Jedan od gornjih "zdravo-svijete" programa napi코ite u nekom
tekst editoru (ako radie na Windowsima onda to moze biti NotePad,
ako ste na Linuxu vi, joe, emacs, ako na Macintoshu\dots)

\dots

\subsection{Pokretanje programa}

Na windowsima; nakon 코to ste program snimili kao datoteku s ekstenzijom
.py, na캠ite gdje je ikona s tom datotekom i dvaput kliknite na nju.

Na linuxu; u komandnoj liniji treba napisati: "python $<$ime\_datoteke$>$".
Naravno, $<$ime\_datoteke$>$ zamijenite s imenom kojeg ste upisali pri
snimanju.

\dots

\subsection{Python kao kalkulator}

Pokrenete li\footnote{Na windowsima tako da kliknete na ikonu, a
na linuxu tako da u prompt-u upi코ete "python"} program kojeg
dobijete kad instalirate python dobiti cete nesto kao:

\sourcee{
Python 2.2 (\#1, Jan  9 2002, 02:47:26) \\
$[$GCC 2.95.2 19991024 (release)$]$ on darwin \\
Type "help", "copyright", "credits" or "license" for more information.  \\
$>>>$ 
}

Ovdje sada  mozete upisivati naredbe programskog jezika python i
vidjeti rezultat:

\sourcee{
Python 2.2 (\#1, Jan  9 2002, 02:47:26) \\
$[$GCC 2.95.2 19991024 (release)$]$ on darwin \\
Type "help", "copyright", "credits" or "license" for more information.  \\
$>>>$ \var{print 2+3} \\
5 \\
$>>>$ \var{d=2} \\
$>>>$ \var{print d+4} \\
6 \\
$>>>$ 
}

Crvenom bojom su ozna캜ene naredbe koje sam u gornjem slu캜aju
pisao ja, a ostatak je generiralo ra캜unalo (odnosno python
interpreter).

Ovaj na캜in pokretanja python interpretera se zove interaktivni. U
principu sve programe u ovom poglavlju mozete pokretati u interaktivnom
na캜inu jednostavno tako da upisujete liniju po liniju programa.

\section{Komentari u programu}

	Gornji program je sasvim mogao izgledati i ovako:

	\sourcee{
		\com{\# "Hello world" (c) 2001 by "Trlababalan" d.d.}\\
		\wrd{print} "Hello world"
	}

	\textbf{Komentar:}
	Prva linija, ona koja zapo캜inje sa znakom \# je \emph{komentar}.
	Kad interpreter do캠e do ovog znaka on jednostavno presko캜i sve
	코to na캠e nakon tog znaka pa sve do kraja reda.

	Nije lo코e stavljati komentare u va코e programe. Oni koji 캖e slijediti
	캖e u sebi imati puno komentara. 

	Mogli se napisati i ovako:

	\sourcee{
		\com{\# Do코ao 코krtac u restoran pojesti juhu, a u jednom trenutku je\\
		\# morao oti캖i na WC. Naravno, uhvatila ga panika da mu netko\\
		\# ne bi pojeo juhu za to vrijeme, pa je ispod juhe stavio papiri캖\\
		\# na kojeg je napisao "Pljunuo sam u juhu" -- nadaju캖i se da \\
		\# tako nikome ne캖e pasti na pamet niti primirisati njegovoj tanjuru\\
		\# \\
		\# Kad se vratio, otkrio je da je na dnu njegovog papiri캖a netko\\
		\# nadopisao "\dots i ja"}\\
		\\
		\wrd{print} "Hello world"
	}

	Moze i ovo:

	\sourcee{
		\wrd{print} "Hello world" 
		\com{\# ovaj program ispisuje na monitor: "Hello world"}
	}

	U stvari gornja 캜etiri slu캜aja predstavljaju jedan te isti program.

	Postoji jo코 jedan na캜in kako se mogu pisati komentari u programu:

	\sourcee{
		\wrd{print} "Hello world"\\
		\com{""" Ovo je samo \\
		komentar """}
	}

	\vspace{3mm}
	Komentar po캜inje s nizom od tri navodnika i zavr코ava s tri navodnika, a
	moze se protezati preko vi코e linija.

\section{Varijable}	

	Promotrite sljede캖i primjer:



\sourcee{
\var{x} = 5 \\
\textcolor{green}{\# od sada (do daljnjega) varijabla x ima vrijednost 5}\\
\textcolor{blue}{print} "x je", \var{x} \\
\textcolor{green}{\# ispisuje prvo poruku "x je", a nakon nje vrijednost varijable x}\\
\var{y} = 10\\
\textcolor{blue}{print} "...a y je", \var{y}
}

	Nakon 코to ga snimite i pokrenete ispis 캖e biti:

\sourcee{
x je sada 5\\
y ima vrijednost 10
}

	\textbf{Obja코njenje:} u prevom redu programa, gdje pi코e \verb|x = 5| smo
	definirali varijablu \verb|x|. \verb|x| od sada ima vrijednost 5. To ne zna캜i
	da se ta vrijednost ne캖e promijeniti u budu碌osti. 
	Od sad, svaki put kad poku코amo ispisati vrijednost x-a dobiti 캖emo broj 5.

	\textbf{Napomena:} znak "=" u prvom redu programa ne treba shvatiti kao
	matemati캜ku tvrdnju da je \verb+x+ isto 코to i 5, odnosno da \verb+x+ ima
	vrijednost 5. Redak "\verb+x = 5+" treba shvatiti kao "Od sada 캖e \verb+x+
	imati rijednost 5" ili "Neka \verb+x+ ima vrijednost 5". Dakle varijabli
	\verb+x+ \underline{pridruzujemo vrijednost} 5.

	U trenutku kad smo u programu napisali \verb|x = 5| kazemo da smo varijablu
	\emph{inicijalizirali}, dakle odredili smo joj neku po캜etnu vrijednost. Ako
	poku코amo ispisati neku neinicijaliziranu varijablu interpreter 캖e nam ispisati
	poruku o gre코ci:

	\sourcee{
	\textcolor{blue}{print} \var{x} \textcolor{green}{\# ...ali varijabla x nije prethodno inicijalizirana!}
	}

	Rezultat je:

	\sourcee{
Traceback (most recent call last):
\\
File "primjer.py", line 1, in ?
\\
print x
\\
NameError: name 'x' is not defined
	}

	Obratite paznju na to da vam se to캜no kaze gdje je gre코ka u programu
	("line 1"). To nam sad i nije od neke koristi jer na코 program ima samo jednu
	liniju, ali kad se stvari zakompliciraju onda 캖emo takve informacije jako puno
	koristiti!
	
	Pogledajmo sljede캖i primjer:

	\sourcee{
	\var{x} = 5 \textcolor{green}{\# x ima sada vrijednost 5}\\
	\textcolor{blue}{print} "x je", \var{x} \textcolor{green}{\# ispisujemo vrijednost od x}\\
	\var{y} = \var{x} \textcolor{green}{\# sada y poprima vrijednost varijable x}\\
	\textcolor{blue}{print} "y je", \var{y} \textcolor{green}{\# ispisujemo vrijednost od y}\\
	\var{x} = 10 \textcolor{green}{\# x je sad 10}\\
	\textcolor{blue}{print} "x je sad ", \var{x} \textcolor{green}{\# ispisujemo x}\\
	\textcolor{blue}{print} "y je sad", \var{y} \textcolor{green}{\# ispisujemo y}
	}

	Kad pokrenemo program ispis je:

	\sourcee{
	x je 5\\
	y je 5\\
	x je sad 10\\
	y je sad 5
	}

	Prvo je \verb|x| bio 5, tada smo varijabli \verb|y| dodijelili vrijednost varijable
	\verb|x|, dakle 5. Tada smo \verb|x| promijenili da sadrzi 10, ali \verb|y| je
	ostao 5 otprije.

\section{Naredbe}

	Program se sastoji od niza naredbi. Svaka naredba ra캜unalu govori 코ta
	treba 캜initi. Razmotriti 캖emo jo코 jednom jedan primjer programa
	pisanog u Pythonu:
	
	\sourcee{
		\var{x} = 5;\\
		\wrd{if} \var{x} $<$ 10:\\
		\hspace*{10mm}\textcolor{blue}{print} "x je manje od 10"\\
		\wrd{else}:\\
		\hspace*{10mm}\textcolor{blue}{print} "x je ve캖e od 10"
	}

	Python je programski jezik koji zahtijeva da se svaka naredba pi코e u odvojenom
	retku. Tako, svaki red predstavlja jednu naredbu, u prvom redu naredba "=" kaze
	ra캜unalu da varijabli \verb|x| pridruzi vrijednost 5. Nakon toga jedan
	\verb+if+--\emph{uvijet}\footnote{Vi코e rije캜i o uvjetima kasnije\dots} 
	(naredba \verb+if+)
	provjerava je
	li x manji od 10, ako jest onda ispisuje s \verb+print+ poruku "x je manji od 10", a ako nije onda
	poruku "x je ve캖e od 10". Program 캖e, naravno, ispisati prvu poruku

	Naredbu \verb+print+ smo upoznali kod pisanja "Hello world" programa -- ona ispisuje na monitor ono 코to se nalazi iza nje.
	O toj naredbi 캖emo jo코 puno pri캜ati kasnije.

	U nekim programskim jezicima mogu se pisati
	programi koji u jednoj liniji imaju vi코e naredbi. Pogledajte na primjer kra캖i
	od dva programa pisana u programskom jeziku Perl u odjeljku 1.3.1. -- ono za
	코to nam u Pythonu treba 5 redova mozemo u Perlu napisati dva reda (mogo bi
	se i u jednom).
	Mozda vam se to moze 캜initi prakti캜nim, ali takvi programski jezici
	rezultiraju s programima koji su vrlo te코ko shvatljivi. U takvom programu je
	vrlo te코ko na캖i gre코ku.

	Pogledajmo jo코 jednom taj program u programskom jeziku Perl:

	\source{Perl:}{
		x = 5;\\
		print x $==$ 10 ? "x je manji od 10$\setminus$n" : "x je ve캖i od 10$\setminus$n";
		}

	Ako znate imalo engleskog onda bi vam prvi primjer pisan u Pythonu trebao biti
	dosta jasan, 캜ak i ako ne znate programirati. Pogledajte sad ovaj drugi
	primjer, on je toliko zgusnut i kripti캜an da je programeru-po캜etniku vrlo
	te코ko shvatiti 코ta je ovdje 코ta. Zamislite da sad imate program koji
	ima 1000 ovakvih linija, a znate da se negdje me캠u njima nalazi jedna
	gre코ka?!

	\textbf{Zapamtite:} Uvijek se potrudite pisati pregledne programe. Svaku komandu
	pi코ite u novu liniju. Svaki slozeniji dio programa popratite s komentarima!
	Desiti 캖e vam se da morate prepraviti program koji ste nekad davno pisali. To
	캖e biti tim lak코e 코to ste tada taj program preglednije pisali!
	
\section{Imena}

	U zadnja dva primjera u na코im programima koristili smo se varijablama. Te
	varijable smo nazvali \verb+x+ i \verb+y+. Naravno, mogli smo ih nazvati i
	druk캜ije. Probati 캖emo ne코to nau캜iti iz sljede캖eg primjera:

	\sourcee{
\var{pi} = 3.1415926 \\
\var{v} = 5 \\
\var{V} = 10 \\
\var{nova}\_varijabla = 12345 \\
\var{var1} = 12 \\
\var{var2} = 13 \\
\textcolor{blue}{print} "pi je",\var{pi} \\
\textcolor{blue}{print} "varijabla v ima vrijesnost",\var{v} \\
\textcolor{blue}{print} "varijabla V (veliko slovo!) ima vrijesnost",\var{V} \\
\textcolor{blue}{print} "jos jedna varijabla:", \var{nova\_varijabla} \\
\textcolor{blue}{print} "var1 je", \var{var1}, ", a var2 je", \var{var2} 
	}

	Prvih 6 linija programa varijablama pridruzuje neke vrijednosti. Imena tih
	varijabli su 
	\verb+pi+,
	\verb+v+,
	\verb+V+,
	\verb+nova_varijabla+,
	\verb+var1+ i 
	\verb+var2+.

	\textbf{Vazno:} Uo캜ite da Python razlikuje velika i mala
	slova: varijabli \verb+v+ smo
	pridruzili vrijednost 5, a varijabli \verb+V+ (veliko slovo V) vrijednost 10.
	Kasnije u programu se njih tretira kao dvije razli캜ite varijable!

	Kad daj program upi코ete i pokrenete dobiti 캖ete:

	\sourcee{
	pi je 3.1415926\\
	varijabla v ima vrijesnost 5\\
	varijabla V (veliko slovo!) ima vrijesnost 5\\
	jos jedna varijabla: 12345\\
	var1 je 12 , a var2 je 13
	}

	\textbf{Zapamtite:} Imena varijabli se mogu sastojati kombinacije velikih i malih
	slova, decimalnih znamenaka
	i znaka "\_"\footnote{Engleski: underscore}. Decimalna znamenka se ne smije
	nalaziti na prvom mjestu imena varijable. Razlikuju se velika i mala slova; dakle
	\verb+kikiriki = 5+ i \verb+Kikiriki = 10+ su dvije razli캜ite varijable s
	razli캜itim vrijednostima! 

	Ima jo코 jedno pravilo kojeg se morate drzati kod odre캠ivanja imena
	varijable; ime varijable \emph{ne smije biti klju캜na rije캜!}

\section{Klju캜ne rije캜i}

	Klju캜ne rije캜i su "rije캜i" ili nizovi znakova koje su rezervirane za
	kori코tenje u programskom jeziku i ne smiju se koristiti za imenovanje varijabli
	ili nekih drugih dijelova programa koje odre캠uje programer. Ve캖 smo se
	sreli s  naredbom \verb+print+. \verb+print+ je klju캜na rije캜 i ne smije
	biti kori코tena kao ime varijable. Mozemo na코u varijablu imenovati npr
	\verb+var_print+ ili \verb+_print+ ili \verb+print1+, ali nikako \verb+print+!

	Svaki programski jezik ima odre캠eni broj klju캜nih rije캜i. Klju캜ne
	rije캜i u programskom jeziku Python su:

\begin{center}
\begin{tabular}{llll}
and & del & for & is \\
raise & assert & elif & from\\
lambda & return & break & else\\
global & not & try & class\\
except & if & or & while\\
continue & exec & import & pass\\
def & finally & in & print
\end{tabular}
\end{center}

	Radi prakti캜nosti, u programima koji se nalaze u ovoj knjizici klju캜ne
	rije캜i su prikazane u plavoj boji.

\section{Komuniciranje s okolinom}

	Ra캜unalo nema previ코e smisla ako ne komunicira s okolinom. Pod
	\emph{komunikacija s okolinom} podradzumijeva se komunikacija s korisnikom ili
	komunikacija s nekim drugim ure캠ajem vezanim uz ra캜unalo. Ra캜unalo
	komunicira s korisnikom na razli캜ite na캜ine; npr. klikanjem po ikonama,
	upisivanjem teksta u nekakav formular, diktiranjem u mikrofon spojen 
	na ra캜unalo, i tako dalje i tako blize.

	Nau캜iti 캖emo sada jedan jednostavan na캜in kako mozemo na코 program u
	pythonu natjerati da i komunicira s nama.

	\sourcee{
		\var{name} = \textcolor{blue}{raw\_input}( "Upi코ite svoje ime:" )\\
		\textcolor{blue}{print} "Dobar dan", \var{name}
	}

	Kad pokrenete program ra캜unalo 캖e ispisati poruku "Upi코ite svoje ime:" i
	traziti od vas da upisujete ime. Rezultat moze biti:

	\sourcee{
		Upi코ite svoje ime:\textcolor{blue}{Aleksandar Makedonski}\\
		Dobar dan  Aleksandar Makedonski
	}

	Plavom bojom je ozna캜en tekst kojeg upisuje sam korisnik.

	Pomo캖u naredbe \verb+raw_input+ sad mozemo bilo kojoj varijabli 
	pridruziti vrijednost broja kojeg 캖e korisnik utipkati tek u trenutku kad 
	se program pokrene. \verb"raw_input" je sli캜an, ali s njime mozemo toj
	varijabli pridruziti i vrijednost stringa (a ne isklju캜ivo brojevnu
	vrijednost).

	Porobati 캖emo sada napisati program koji trazi od korisnika da upi코e 
	tri broja, a nakon toga ispisuje njihovu aritmeti캜ku sredinu (prosijek).

	\sourcee{
		\var{n1} = \textcolor{blue}{input}( "Upi코i prvi broj:" )\\
		\var{n2} = \textcolor{blue}{input}( "Upi코i drugi broj:" )\\
		\var{n3} = \textcolor{blue}{input}( "Upi코i tre캖i broj:" )\\
		\var{avg} = ( \var{n1} + \var{n2} + \var{n3} ) / 3\\
		\textcolor{blue}{print} "Aritmeti캜ka sredina je ", \var{avg}
	}

	\textbf{Komentar:} Program prvo u varijable \verb+n1+, \verb+n2+ i \verb+n2+
	smje코ta ono 코to 캖e korisnik sam upisati kad ga se upita da upi코e broj.
	Varijabla \verb"avg" (eng. "average" = "prosjek") zatim prime vrijednost
	aritmeti캜ke sredine brojeva 
	\verb"n1",
	\verb"n2" i 
	\verb"n3".
	Na kraju se samo ispisuje vrijednost od \verb"avg".

	Evo jo코 dvije varijante istog programa:

	\sourcee{
		\var{n1} = \textcolor{blue}{input}( "Upi코i prvi broj:" )\\
		\var{n2} = \textcolor{blue}{input}( "Upi코i drugi broj:" )\\
		\var{n3} = \textcolor{blue}{input}( "Upi코i tre캖i broj:" )\\
		\var{avg} = ( float( \var{n1} ) + float( \var{n2} ) + float( \var{n3} ) ) / 3\\
		\textcolor{blue}{print} "Aritmeti캜ka sredina je ", \var{avg}
	}

	Ili jo코 kra캖e:

	\sourcee{
		\var{n1} = float( \textcolor{blue}{input}( "Upi코i prvi broj:" ) )\\
		\var{n2} = float( \textcolor{blue}{input}( "Upi코i drugi broj:" ) )\\
		\var{n3} = float( \textcolor{blue}{input}( "Upi코i tre캖i broj:" ) )\\
		\textcolor{blue}{print} "Aritmeti캜ka sredina je ", ( \var{n1} + \var{n2} + \var{n3} ) / 3
	}

	\textbf{Napomena:} \verb+float()+ nije jedini na캜in kako se string moze
	pretvoriti u broj. U sljede캖em poglavlju 캖e biti obja코njeno za코to se
	ovdje koristi ba코 taj.

\chapter{Izrazi}

\section{Aritmeti캜ki izrazi}

Aritmeti캜ki izrazi su matemati캜ki izrazi s kakvima se ra캜una u
osnovnoj 코koli. Naj캜e코캖e se sastoje od brojeva ili varijabli
koje imaju broj캜anu vrijednost i matemati캜kih operacija. Primjer
aritmeti캜kog izraza moze biti: 
$2+4-2$, 
$\displaystyle \frac{3+6\cdot 5}{7-4}$,
ili 
$\displaystyle \frac{s_2-s_1}{t_2-t_1}$. 

Kad nam negdje u programu zatreba
aritmeti캜ki izraz zapisujemo ga na sli캜an na캜in kako bismo ga napisali u
biljeznici s nekoliko sitnih razlika;

\begin{itemize}
	\item Mnozenje zapisujemo pomo캖u znaka *, a ne $\cdot$.
	\item Dijeljenje zapisujemo pomo캖u znaka / umjesto :
	\item Razlomke zapisujemo pomo캖u operacije dijeljenja.
	\item Potencije zapisujemo pomo캖u "**". Dakle $3^2$ bi zapisalo kao
		3**2
	\item Ostatak\footnote{"Modulo"} pri dijeljenju dobijemo pomo캖u
		operacije \%.
\end{itemize}

Izraz 
$\displaystyle \frac{3+6\cdot 5}{7-4}$
bi napisali: \verb+(3+6*5)/(7-4)+. U ovom
slu캜aju brojnik i nazivnik treba staviti unutar zagrada jer bi u
slu캜aju da je izraz \verb+3+6*5/7-4+ kompjuter poku코ao prvo
izra캜unati \verb+6*5/7+, python naime izraze ra캜una paze캖i na
prednost ra캜unskih operacija (npr. mnozenje i dijeljenje imaju
prednost pred zbrajanjem i oduzimanjem).

\textbf{Vazno:}
Ima jo코 jedna stvar na koju treba pripaziti pri pisanju algebarskih
izraza; ukoliko su brojevi s kojima ra캜unamo cjelobrojni onda 캖e (u
programskom jeziku python) i rezultat biti cjelobrojan. Dakle, ako probate
izra캜unati \verb+13/4+ dobiti 캖ete \verb+3+, a ne \verb+3.25+! To se
moze rije코iti tako da barem jedan od brojeva definiramo kao realan, a za
to je dovoljno dodati mu decimalnu to캜ku na kraju. Da bi dobili to캜an
rezultat dijeljenje 13 podijeljeno s 4 trebali bi dakle napisati
\verb+13/4+.

Zadaci:

\section{Logi캜ki izrazi}

Sli캜no kao aritmeti캜ki izrazi logi캜ki izrazi se sastoje od
operacija i 캜lanova izraza nad kojima ze izvr코avaju te operacije.
Kod aritmeti캜kih izraza 캜lanovi su brojevi ili varijable s
brojevnom vrijedno코캖u, a 캜lanovi logi캜kih izraza mogu biti
\emph{sudovi} ili 캜ak drugi aritmeti캜ki izrazi.

\emph{Sud} je tvrdnja koja moze biti istinita ili lazna. Primjer
suda je \emph{"Zemlja kruzi oko Mjeseca"} ili \emph{"Postoji
beskona캜no mnogo prirodnih brojeva"}.  Svaki sud mora imati svoju
istinosnu vrijednost koja moze biti \emph{"istina"} ili \emph{"laz"}.
Ukoliko za neku tvrdnju ne mozemo sa sigurno코캖u kazati je li
istinita ili lazna tada to nije sud. Na primjer \emph{"Zemlja
kruzi oko Mjeseca"} jest sud zato 코to ima istinosnu vrijednost
\emph{"laz"}, kao i \emph{"Postoji beskona캜no mnogo prirodnih
brojeva"} 캜ija je istinita vrijednost \emph{"istina"}.  Tvrdnja
\emph{"Frank Sinatra pjeva bolje od Tine Turner"} nije sud jer je
nemogu캖e odrediti istinitost te tvrdnje budu캖i da je ona 캜isto
subjektivne prirode (nekome se vi코e svidja Sinatra, a nekome Tina
Turner). Isto tako nije sud "U캜ini to!" ili "Mozda 캖u jednog
dana nau캜iti programirati".

Umjesto "istina" ili "laz" se 캜esto koriste velika slova "T" (od
engleskog "true" = "istina") odnosno "F" (eng. "false" = "laz").

Sud mozemo zapisati i matemati캜kim simbolima: $1<2$ je sud u
kojemu se tvrti da je jedan manji od 2, a istinosna vrijednost tog
suda je T (= istina). Matemati캜ki sudovi kojima se koristimo u
programiranju naj캜e코캖e se koriste za opisivanje odnosa izmedju
brojeva. Pri tome se koristimo sljede캖im simbolima iz sljede캖e tablice;
u prvom stupcu se nalazi simbol kako bismo za zapisali u biljeznicu
ili na plo캜u, u drugom stupcu zapisa tog istog simbola u programu,
a u tre캖em kako 캜itamo taj simbol:

\begin{tabular}{lll}
	$=$ & $==$ & je jednako \\
	$\neq$ & $!=$ & nije jednako, je razli캜ito \\
	$<$ & $<$ & je manje od \\
	$\leq$ & $<=$ & je manje ili jednako \\
	$>$ & $>$ & je ve캖e od \\
	$\geq$ & $>=$ & je ve캖e ili jednako
\end{tabular}

Probajmo sada utvrditi istinosnu vrijednost nekih matemati캜kih izraza:

\begin{tabular}{lll}
	$12<12.01$ & \verb+12<12.01+ & T\\
	$1+2\leq 5$ & \verb"1+2<=5" & T\\
	$10-3\geq 6+1$ & \verb"10-3>=6+1" & T \\
	$10-2\geq 6+1$ & \verb"10-2>=6+1" & F \\
	$5\neq 5$ & \verb"5!=5" & F
\end{tabular}

Gornji primjeri su primjeri \emph{jednostavnih sudova}. Slozeni
sudovi su sudovi koji se dobijaju od jednostavnih sudova i logi캜kih
operacija \emph{and}, \emph{or} i \emph{not}.

\subsection{Logi캜ka operacija \emph{and}}

Promotrimo re캜enicu \emph{"Ako je lijepo vrijeme
idemo na izlet."}. O 캜emu ovisi o캖ete li
oti캖i na izlet? Ovisi o tome je li lijepo vrijeme, dakle ovisi o
istinosnoj vrijednosti suda \emph{"Lijepo je vrijeme."}. Ako je
taj sud istinit (T) oti캖i 캖ete na izlet, a ako nije (F) -- ni코ta
od izleta.

Malo 캖emo stvar zakomplicirati ako osim lijepog vremena va코 izleta
ovisi o jo코 ne캜emu; \emph{"Ako je lijepo vrijeme i nemam drugih obaveza
i캖i 캖u na izlet"}.
Sad va코 izlet ovisi o istinitosti suda \emph{"Lijepo je vrijeme i nemam obaveza"}, a on je istinit
kad su istovremeno istinita sljede캖a dva suda:

\begin{itemize}
	\item[\emph{(a)}] \emph{"Lijepo je vrijeme."}
	\item[\emph{(b)}] \emph{"Nemam obaveza."}
\end{itemize}

Dakle, treba vrijediti da je istinito i \emph{(a)} i \emph{(b)},
jer ako je bilo koje od ta dva laz onda je i tvrdnja \emph{"Lijepo
je vrijeme i nemam obaveza"} lazna.

Ukoliko imamo dva suda koja 캖emo ovdje ozna캜iti s $A$, odnosno
$B$ onda 캖emo takvu kombinaciju zapisivati s $A and B$. Suda $A
and B$ je \emph{slozeni sud} koji se sastoji od jednostavnijih
sudova $A$ i $B$. Istinitost suda $A and B$ ovisi o istinitosti
sudova $A$ i $B$; tek ako su oba istinita onda je i $A and B$
istinit. To se moze prikazati pomo캖u sljede캖e tablice:

\begin{tabular}{ll|l}
	$A$ & $B$ & $A and B$ \\
	\hline
	istina & istina & istina \\
	istina & laz & laz \\
	laz & istina & laz \\
	laz & laz & laz 
\end{tabular}

Garnju tablicu zovemo \emph{tablica istinitosti} logi캜ke operacije $and$.

\subsection{Logi캜ka operacija \emph{or}}

Pretpostavimo da 캖ete oti캖i na izlet ako vrijedi \emph{"Lijepo
je vrijeme ili imam dobro dru코tvo"}. Dakle, ako je lijepo vrijeme
idete na izlet, ako nije lijepo vrijeme i imate dobro dru코tvo ipak
idete na izlet, ako nemate dobro dru코tvo i lijepo je vrijeme opet
idete na izlet, a jedini slu캜aj kad ne idete na izlet je kad, niti
je vrijeme lijepo niti imate dobro dru코tvo.

Tablica istinitosti logi캜ke operacije $or$ izgleda ovako:

\begin{tabular}{ll|l}
	$A$ & $B$ & $A or B$ \\
	\hline
	istina & istina & istina \\
	istina & laz & istina \\
	laz & istina & istina \\
	laz & laz & laz 
\end{tabular}

\subsection{Logi캜ka operacija \emph{not}}

U zadnjem slu캜aju oti캖i 캖ete na izlet tek ako vrijedi \emph{"Nemam
drugih obaveza"}. Dakle, tek ako \emph{nije} istit sud \emph{"Imam
drugih obaveza"}. Logi캜ka operacija $not$ nekom sudu pridodaje
suprotanu istinosnu vrijednost.

\begin{tabular}{l|l}
	$A$ & $not A$ \\
	\hline
	istina & laz\\
	laz & istina
\end{tabular}

Zadaci: Probajte odrediti istinitost sljede캖ih sudova:
	- 1<2 and 13!=5
	- 2>5 or 1=2
	- 1<2 and 5!=5
	- ( 1<2 or 9=5 ) and 3==3
	- ( 2==2 and 3!=5 ) or ( 3==4 )

\subsection{Nekoliko dodatnih pravila}

U programskom jeziku python (sli캜no kao u mnogim drugim) postoji
jo코 nekoliko dodadnih pravila kod utvrdjivanjaistinitosti sudova:
- svaki broj/izraz je po definiciji sud:
	- ako njegova vrijednost 0 onda je njegova istinosna vrijednost "laz" (F)
	- ako je razli캜it od 0 onda je njegova istinosna vrijednost "istina" (T)
- svaki string je po definiciji sud:
	- ako je string prazan onda je njegova istinosna vrijednost "laz" (F)
	- ako string nije prazan onda je njegova istinosna vrijednost "istina" (T)

dakl ima smisla sud \verb"2<3 or 0". Budu캖i da je $2<3$ ondaje prvi dio suda istinit, a (broj) 0 je
po gornjim pravilima lazan, dakle imamo slu캜aj "istina" $or$ "laz", dakle rezultat je istina.

Zadaci: Probajte odrediti istinitost sljede캖ih sudova:
\begin{itemize}
\item \verb"1 or 3>3"
\item \verb"2!=3 and 1"
\item \verb+"" or "jkljkl"+
\item \verb+( 0 or "jkljkl" ) and 2<3+
\item \verb+( not "jkljkl" ) and ( not 12 )+
\end{itemize}
\chapter{Kontrola toka programa}

\section{if \dots then \dots else \dots}

Pretpostavimo da imamo program koji od korisnika trazi da upi코e
koliko je bodova zaradio na odre캠enom testu i zatim ovisno o broju
bodova ispisuje koju je ocjenu dobio. Ako je dobio manje ili jednako
39 bodova ocjena je 1, ako ima 40-54 ocjena je 2, za 55-69 ocjena
je 3, za 70-85 ocjena je 4, a za vi코e od 85 ocjenjen je s 5.

Probati 캖emo za po캜etak napisati program koji samo ispisuje je
li ocjena 1 ili ve캖a. Za to program treba nekako imati na캜in kako
캖e provjeriti je li broj bodova ve캖i, manji ili jednak 40.

Program izgleda ovako:

\sourcee{
\var{bodovi} = \wrd{input}( "Upi코i broj bodova:" )
\\
\wrd{print} "Imate", bodovi, "bodova..."
\\
\wrd{if} \var{bodovi} $<$ 40:
\\
\hspace*{10mm}\wrd{print} "Nazalost dobili ste negativnu ocjenu :("
\\
\wrd{print} "Kraj programa"
}

Kori코tena je naredba if, ona se koristi na sljede캖i na캜in:

\sourcee{
\wrd{if} \emph{logi캜ki izraz}:
\\
\hspace*{10mm}\emph{komande programa u slu캜aju da je logi캜ki izraz istinit}
}

Kao prvo uo캜ite da je dio programa koji seizvr코ava u slu캜aju da
je logi캜ki izraz istinit \emph{uvu캜en} u odnosu na ostatak
programa. To uvla캜enje je to캜no definirano i mora biti jedan
$<$tab$>$ (ili 8 razmaknica) ra캜unaju캖i od lijevog ruba polja u kojem se
editira program!

U po캜etnom programu se komanda nakon \verb"if" naredbe izvr코ava
jedino u slu캜aju ako je broj bodova manji od 40, ako je broj bodova
ve캖i ili jednak 40 program tu liniju jednostavno preska캜e. Mozemo
srediti i da program preska캜e ve캖i broj linija:

\sourcee{
\var{bodovi} = \wrd{input}( "Upi코i broj bodova:" )
\\
\wrd{print} "Imate", bodovi, "bodova..."
\\
\wrd{if} \var{bodovi} $<$ 40:
\\
\hspace*{10mm}
	\wrd{print} "Nazalost dobili ste negativnu ocjenu :("
\\
\hspace*{10mm}
	\wrd{print} "Molimo vas lijepo da za sljede캖i put malo bolje nau캜ite"
\\
\wrd{print} "Kraj programa"
}

Poruka koja se sad ispisuje ukoliko nemate dovoljno bodova je 

\sourcee{
Nazalost dobili ste negativnu ocjenu :(
\\
Molimo vas lijepo da za sljede캖i put malo bolje nau캜ite
}

Opet, \verb"Kraj programa" se ispisuje bez obzira na broj bodova.

Zelimo li da na코 program ispisuje i poruku ukoliko imate vi코e ili jednako od 40 bodova to se moze
tako da koristite dva puta naredbu \verb"if":

\sourcee{
\var{bodovi} = \wrd{input}( "Upi코i broj bodova:" )
\\
\wrd{print} "Imate", bodovi, "bodova..."
\\
\wrd{if} \var{bodovi} $<$ 40:
\\
\hspace*{10mm}
	\wrd{print} "Nazalost dobili ste negativnu ocjenu :("
\\
\wrd{if} \var{bodovi} $>$= 40:
\\
\hspace*{10mm}
	\wrd{print} "Imate vi코e od 40 bodova"
\\
\wrd{print} "Kraj programa"
}

Ili pomo캖u jednog dodatka naredbi \verb"if":

\sourcee{
\var{bodovi} = \wrd{input}( "Upi코i broj bodova:" )
\\
\wrd{print} "Imate", bodovi, "bodova..."
\\
\wrd{if} \var{bodovi} $<$ 40:
\\
\hspace*{10mm}
	\wrd{print} "Nazalost dobili ste negativnu ocjenu :("
\\
\wrd{else}:
\\
\hspace*{10mm}
	\wrd{print} "Imate vi코e od 40 bodova"
\\
\wrd{print} "Kraj programa"
}

Program govori ra캜unalu:
\emph{Ako je broj bodova manji od 40 tada ste dobili negativnu
ocjenu, ina캜e imate vi코e od 40 bodova}

Sve ono 코to se nalazi nakon \verb"else", naravno uvu캜eno za jedan
$<$tab$>$ 캖e biti ispisano u slu캜aju da uvjet \verb"bodovi$<$40" nije
istinit!

Sta ako ne zelimo samo podatak o tome jesmo li dobili vi코e ili
manje od 40 bodova nego i koju smo ocjenu dobili:

Prvi na캜in koriste캖i niz \verb"if"-ova:

\sourcee{
\var{bodovi} = \wrd{input}( "Upi코i broj bodova:" )
\\
\wrd{print} "Imate", bodovi, "bodova..."
\\
\wrd{if} \var{bodovi} $<$ 40:
\\
\hspace*{10mm}
	\wrd{print} "Nazalost dobili ste negativnu ocjenu :("
\\
\wrd{if} 40$<$=\var{bodovi} and \var{bodovi}$<$=54:
\\
\hspace*{10mm}
	\wrd{print} "Dovoljan (2)"
\\
\wrd{if} 55$<$=\var{bodovi} and \var{bodovi}$<$=69:
\\
\hspace*{10mm}
	\wrd{print} "Dobar (3)"
\\
\wrd{if} 70$<$=\var{bodovi} and \var{bodovi}$<$=84:
\\
\hspace*{10mm}
	\wrd{print} "Vrlo dobar (4)"
\\
\wrd{if} 85$<$=\var{bodovi}:
\\
\hspace*{10mm}
	\wrd{print} "Odli캜an (5)"
}

Drugi na캜in koriste캖i \verb"elif" (od eng. "else if"):

\sourcee{
\var{bodovi} = \var{input}( "Upi코i broj bodova:" )
\\
\wrd{print} "Imate", \var{bodovi}, "bodova..."
\\
\wrd{if} \var{bodovi} $<$ 40:
\\
\hspace*{10mm}
	\wrd{print} "Nazalost dobili ste negativnu ocjenu :("
\\
\wrd{elif} 40$<$=\var{bodovi} and \var{bodovi}$<$=54:
\\
\hspace*{10mm}
	\wrd{print} "Dovoljan (2)"
\\
\wrd{elif} 55$<$=\var{bodovi} and \var{bodovi}$<$=69:
\\
\hspace*{10mm}
	\wrd{print} "Dobar (3)"
\\
\wrd{elif} 70$<$=\var{bodovi} and \var{bodovi}$<$=84:
\\
\hspace*{10mm}
	\wrd{print} "Vrlo dobar (4)"
\\
\wrd{elif} 85$<$=\var{bodovi}:
\\
\hspace*{10mm}
	\wrd{print} "Odli캜an (5)"
}

Na hrvatskom bi ovo napisali: \emph{Ako imate manje od 40 bodova dobili ste 2, ina캜e ukoliko imate
izme캠u 40 i 54 dobili ste 2, ina캜e ukoliko imate izme캠u 55 i 59 dobili ste 3, ina캜e ukoliko imate
izme캠u 70 i 84 dobili ste 4, ina캜e ukoliko imate vi코e od 84 dobili ste 5}.

Mali problem moze nastati u tome 코to mozete napisati i 120 ili -340 za broj bodova. Probajmo
napisati program koji ispravlja tu gre코ku:

\sourcee{
\var{bodovi} = \wrd{input}( "Upi코i broj bodova:" ) \\
\wrd{print} "Imate", \var{bodovi}, "bodova..." \\
\wrd{if} 0$<$= \var{bodovi} and \var{bodovi} $<$ 40: \\
\hspace*{10mm} \wrd{print} "Nazalost dobili ste negativnu ocjenu :(" \\
\wrd{elif} 40$<$=\var{bodovi} and \var{bodovi}$<$=54: \\
\hspace*{10mm} \wrd{print} "Dovoljan (2)" \\
\wrd{elif} 55$<$=\var{bodovi} and \var{bodovi}$<$=69: \\
\hspace*{10mm} \wrd{print} "Dobar (3)" \\
\wrd{elif} 70$<$=\var{bodovi} and \var{bodovi}$<$=84: \\
\hspace*{10mm} \wrd{print} "Vrlo dobar (4)" \\
\wrd{elif} 85$<$=\var{bodovi} and \var{bodovi} $<$=100: \\
\hspace*{10mm} \wrd{print} "Odli캜an (5)" \\
\wrd{else}: \\
\hspace*{10mm} \wrd{print} "Niste upisali broj izme캠u 0 i 100 za broj bodova"
}

Sad bi "prijevod" ovog programa na hrvatski glasio: \emph{Ako imate
izme캠u 0 i 40 bodova dobili ste 2, ina캜e ukoliko imate izme캠u
40 i 54 dobili ste 2, ina캜e ukoliko imate izme캠u 55 i 59 dobili
ste 3, ina캜e ukoliko imate izme캠u 70 i 84 dobili ste 4, ina캜e
ukoliko imate izme캠u 84 i 100 dobili ste 5, a ako nije niti jedan
od ovih slu캜ajeva onda ste pogre코no upsali broj bodova}.

Zadaci: \textbf{Za napraviti}

\section{for \dots in range( \dots )}

Problem je sljede캖i; treba ispisati tablicu kvadrata brojeva od do 10.
Tablica kvadrata je tablica koja ima dva stupca, u prvom se nalazeprirodni
brojevi, a u drugom njihovi kvadrati (da podsjetimo, kvadrat prirodnog
broja dobijemo tako da taj broj pomnozimo sa samim sobom).

To se moze posti캖i na sljede캖i na캜in:

\sourcee{
\wrd{print} "n -$>$ n*n" \\
\wrd{print} 1, " -$>$ ", 1**2 \\
\wrd{print} 2, " -$>$ ", 2**2 \\
\wrd{print} 3, " -$>$ ", 3**2 \\
\wrd{print} 4, " -$>$ ", 4**2 \\
\wrd{print} 5, " -$>$ ", 5**2 \\
\wrd{print} 6, " -$>$ ", 6**2 \\
\wrd{print} 7, " -$>$ ", 7**2 \\
\wrd{print} 8, " -$>$ ", 8**2 \\
\wrd{print} 9, " -$>$ ", 9**2 \\
\wrd{print} 10, " -$>$ ", 10**2
}

\verb"5**2" zna캜i $5^2$. U svakom retku se naredbom print ispisuje broj i
njegov kvadrat. 

Me캠utim, ovo je jedan prili캜no \emph{neelegantan} na캜in rje코avanja
problema, a to zato 코to je ovakav program te코ko generalizirati,
odnosno te코ko ga je upotrijebiti u slu캜aju da njime moramo
rije코iti neki analogni ili opcehnitiji problem. 
\footnote{
	Ako je na코 trenutni
	problem \emph{"Napi코i program koji ispisuje tablicku kvadrata
	prvih 10 brojeva"} analogni (ali slozeniji) problem moze glasiti
	\emph{"Napi코i program koji ispisuje tablicu kvadrata za brojeve
	od 0 do 100"}. Op캖enitiji problem bi mogao biti \emph{"Napi코i
	program koji ispisuje tablicu kvadrata za brojeve od 0 do n (gdje
	je n proizvoljan prirodan broj)"}. 
}
Taj program se moze napisati
na na캜in slu캜an na코em na캜inu, ali priznati 캖ete da pisanje
sto i jedne linije tipa s naredbom \verb"print" koja ne radi ni코ta
drugo negoli ispisuje broj i njegov kvadrat i nije neki pretjerano
kreativan posao.

Zato postoji nareda \verb"for". Ta naredba od ra캜unala trazi da
odre캠eni broj puta ponovi neki postupak uz odre캠ene uvjete. Uz
naredbu \verb"for" se nalazi ime varijable i nekakav \emph{skupa}
ili \emph{lista} prema kojima se ta varijabla "kre캖e". Budu캖i da
캖e se ova skripta baviti skupovima, listama i ostalim slozenim
tipovima podataka baviti tek kasnije ovdje 캖u objasniti samo jedan
od na캜ina koji se 캜esto koriste s naredbom \verb"for".

\sourcee{
\wrd{print} "n -$>$ n*n" \\
\wrd{for} \var{x} \wrd{in} \wrd{range}(11): \\
\tab \wrd{print} \var{x}, " -$>$ ", \var{x}**2
}

Rezultat programa 캖e biti potpuno isti kao i kod pro코log programa.

Druga i tre캖a linija ovog programa kaze otprilike: \emph{"Neka
varijabla x uzima redom vrijednost 0, 1, 2\dots sve dok je manje
od 11, i za svaku od tih vrijednosti ispi코i vrijednost od x i
kvadrat od x"}. Nakon 코to python interpreter do캠e do druge linije
programa ra캜unalo samo varijabli x pridodaje vrijednost 0, i
izvr코ava tre캖u liniju programa (x je tamo 0). Nakon 코to to
izvr코i varijabli x se pridruzuje sljede캖a vrijednost; 1. Sad se
opet ispisuje tre캖a linija programa, ali s novom vrijednos캖u
varijeble x. Nakon toga x poprima vrijednost 2, izvr코ava se tre캖a
linija, i tako dalje\dots

\textbf{Vazno:}
Nikad ne zaboravite dvoto캜ku iza "for" linije -- to je naime vrlo
캜esta po캜etni캜ka gre코ka.

\textbf{Definicija:} Za liniju s \verb"for" naredbom i niz naredbi koje
se izvr코avaju pri svakoj promjeni varijable nakon \verb"for"
kazemo da se zovu \textbf{for-petlja}. Ukoliko je \verb"x" varijabla
nakon \verb"for" kazemo da smo izvr코ili \textbf{for-petlju po varijabli
x}. Svaki put kad varijabla \verb"x" promijeni vrijednost zbog \verb"for"
petlje kazemo da je izvr코eno \textbf{iteracija}. Niz naredbi koje se
izvr코avaju u svakoj iteraciji zovemi tijelo for-petlje.

Isto tako, mozete srediti da se izvr코ava i vi코e linija svaki
put kad varijabla x u zbog \verb"for" mijenja vrijednost. Jednostavno
nakon tre캖eg reda programa napisali biste jo코 jedan, ali i taj
obavezno mora biti pomaknuti za jedan $<$tab$>$ udesno.

Pretpostavimo sad da treba napisati prgram koji od koristnika trazi
da mu upi코e jedan broj, a zatim ispisuje prvo kvadrat tog broja,
a onda rezultat pri cjelobrojnom dijeljenju 
\footnote{
	Cjelobrojno dijeljenje zna캜i da se radi o dijeljenju u
	kojemu se ignorira dio iza decimalne to캜ke u rezultatu
	nekog dijeljenja. Npr ukoliko podijelimo 7 sa 4 dobiti
	캖emo 1.75, ali rezultat cjelobrojnog dijeljenja 7 sa 4 je
	1. Podsjetimo da python vr코i cjelobrojno dijeljenje ukoliko
	su djeljenik i djelitelj cijeli brojevi (nemaju decimalnog
	dijela).
}
tog broja s 2.

\sourcee{
\var{n} = \wrd{input}( "Upi코i broj:" )
\\
\wrd{for} \var{i} \wrd{in} \wrd{range}( \var{n}+1 ):
\\
\hspace*{10mm}
	\wrd{print} "kvadrat od", \var{i}, "je", \var{i}**2
\\
\hspace*{10mm}
	\wrd{print} "rezultat cjelobrojnog dijeljenja od", \var{i}, "s 2 je", \var{i}/2
\\
\wrd{print} "Kraj programa"
}

Ovdje se tijelo for-petlje sastoji od dvije naredbe (tre캖i i
캜etvrti red programa. Zadnja linija ne spada u tijelo petlje jer
se ne izvr코ava kod svake iteracije nego samo jednom nakon 코to se
cijela petlja "izvr코i".

Prvo se varijabli \verb"n" pridjeljuje vrijednost koju upisuje
osoba koja pokre캖e program. Zatim se vr코i petlja po varijabli
\verb"i". Obratite paznju da se petlja sad kre캖e u granicama od
0, pa po svim cijelim brojevima manjim od \verb"n+1", a najve캖i
cijeli broj manji od \verb"n+1" je \verb"n". Dakle petlja se ne
izvra코ava za \verb"n+1" nego samo do \verb"n", a to je upravo ono
코to mi zelimo.

Zelimo sad program koji 캖e za svaki broj od 0 do 100 ispisati
njegov kvadrat i, ukoliko je taj broj paran ispisati i poruku o
tome. Broj je paran u koliko je rezultati pri dijeljenju tog broja
s 2 jednak s 0. Rezultat pri dijeljenju dobijemo pomo캖u operacije
modulo (\verb"%" u python programu)

\sourcee{
\wrd{for} \var{x} \wrd{in} \wrd{range}(101): \\
\tab \wrd{print} \var{x}, "na kvadrat iznosi", \var{x}**2 \\
\tab \wrd{if} \var{x} \% 2 == 0: \\
\tab \wrd{print} \var{x}, "je paran broj" \\
\wrd{print} "Kraj programa"
}

\textbf{Komentar:} Tijelo for-petlje koja po캜inje s prvim redom
programa je niz naredbi koji se sastoji od 2-4 linije programa.
Obratite paznju da je ovdje 4. linija, koja se izvr코ava jedino
kad je istinit sud \verb"x%2==0" pomaknuta za \emph{dva} $<$tab$>$-a!
Za svaki \verb"x" if-uvjet isprobava je li istina da je rezultat
pri djeljenju x s 2 jednak 0 (\verb"x%2==0"), a ako je to istina
izvr코ava se 4. linija.

Evo jo코 jedna varijanta programa:
\footnote{
Zbog lak코eg opisivanja programa ovdje je na po캜etku svakog retka
ispisan i redni broj tog reda. Kad prepisivanja programa u editoru to n
prepisujete.
}

\sourcee{
1: \wrd{for} \var{x} \wrd{in} \wrd{range}(101): \\
2:\tab \wrd{print} \var{x}, "na kvadrat iznosi", \var{x}**2 \\
3:\tab \wrd{if} \var{x} \% 2 == 0: \\
4:\tab \tab \wrd{print} \var{x}, "je paran broj" \\
5:\tab \wrd{else}: \\
6:\tab \tab \wrd{print} \var{x}, "nije paran broj" \\
7:\tab \wrd{print} \\
8: \wrd{print} "Kraj programa"
}

U 캜emu se ona razlikuje od gornjeg programa? Probajte sami otkriti 코ta
radi sedma linija programa? Ovisi li njeno izvr코avanje o tome je li
izvr코en uvjet u 3. redu? Probajte promijeniti program tako da se petlja ne
izvr코ava za brojeve do 100 nego da korisnik moze sam odrediti do kojeg do
kojeg broja se petlja izvr코ava.

Probajte objasniti za코to donji program radi potpuno istu stvar
kao i na코 zadnji program:\footnote{Pomo캖: svaki broj je po definiciji sud
캜ija istinitost ovisi o\dots}

\sourcee{
1: \wrd{for} \var{x} \wrd{in} \wrd{range}(101): \\
2: \tab \wrd{print} \var{x}, "na kvadrat iznosi", \var{x}**2 \\
3: \tab \wrd{if} \wrd{not} \var{x} \% 2: \\
4: \tab \tab \wrd{print} \var{x}, "je paran broj" \\
5:	\tab \wrd{else}: \\
6: \tab\tab \var{x}, "nije paran broj" \\
7: \tab \wrd{print} \\
8: \wrd{print} "Kraj programa"
}

Jo코 jedna korisna varijanta varijanta for-petlja s \verb"range(...)" je
slu캜aj u kojem ne zelim da se petlja izvr코ava za brojeve od 0 do nekog
broja nego od nekog broja razli캜itog od 0 do nekog drugog broja:

\sourcee{
\wrd{for} \var{i} \wrd{in} \wrd{range}( 15, 70 ):\\
\hspace*{10mm} \wrd{print} \var{i}
}

Ispisati 캖e brojeve od 15 do 70.

Probajte objasniti 코ta radi sljede캖i program:

\sourcee{
\var{a} = \wrd{input}( "Upi코i prvi broj:" ) \\
\var{b} = \wrd{input}( "Upi코i prvi broj:" ) \\
\wrd{if} \var{a} $<$ \var{b}: \\
\hspace*{10mm} \wrd{for} \var{x} \wrd{in} \wrd{range}( \var{a}, \var{b} + 1 ): \\
\hspace*{10mm} \hspace*{10mm} \wrd{print} \var{x}, "na tre캖u iznosi", \var{x}**3 \\
\wrd{else}: \\
\hspace*{10mm} \wrd{print} "hmmm..."
}

Napi코ite sada program koji od korisnika trazi da upi코e dva broja, a
zatim ispisuje tablicu kvadrata svh brojeva od prvog do drugog.

Evo jo코 jedan zanimljiv program koji ispisuje tablicu mnozenja brojeva od
1 do 10. Treba dakle napisati sve izraze oblika $a\cdot b$ gdje $a$ i $b$
mogu biti brojevi od 1 do 10. Ali (!) za svaki $a$ od 1 do 10 (for-petlja)
i $b$ mora mo캖i poprimiti vrijednosti od 1 do 10.

\sourcee{
\wrd{for} \var{a} \wrd{in} \wrd{range}(1, 11): \\
\hspace*{10mm} \wrd{for} \var{b} \wrd{in} \wrd{range}(1, 11): \\
\hspace*{10mm} \hspace*{10mm} \wrd{print} \var{a}, "puta", \var{b}, "je jednako", \var{a}*\var{b}
}

Tijelo prve petlje je drugi i tre캖i red, a tijelo druge petlje je samo
tre캖i red. Dakle, za svaki a od 1 do 10 izvr코iti 캖e se druga petlja u
kojoj se sad b mijenja od 1 do 10 i kod svake promjene ispisuje poruka.

Jo코 jedan primjer:

Pretpostavimo da imamo ovakav problem:
Polaznik jedne auto코kole polazu pismeni dio voza캜kog ispita.
Ispit se sastoji od 15 pitanja koji su podijeljeni u tri skupine po 5 zadatka.
Zadaci iz prve skupine nose po 1 bod, iz druge skupine 2 boda, a iz tre캖e
skupine po 3 boda. Za prolaz na ispitu potrebno je da polaznik ima barem 24 boda.
Treba napisati program koji od instruktora trazi da upi코e broj to캜nih
zadataka iz prve, druge i tre캖e skupine i onda ispisuje je li polaznik
auto코kole zadovoljio uvjete.

Program bi mogao izgledati ovako:

\sourcee{
\var{a} = \wrd{input}( "Broj tocnih zadataka u prvoj skupini:" ) \\
\wrd{b} = \wrd{input}( "Broj tocnih zadataka u drugoj skupini:" ) \\
\var{c} = \wrd{input}( "Broj tocnih zadataka u trecoj skupini:" ) \\
\wrd{if} \var{a}+\var{b}+\var{c} $>$= 24: \\
\hspace*{10mm} \wrd{print} "Polaznik je polozio ispit" \\
\wrd{else}: \\
\hspace*{10mm} \wrd{print} "Polaznik nije polozio ispit"
}

Ukoliko znamo da ta auto코kola ima 20 polaznika mozemo srediti da program
radi za sve polaznike auto코kole:

\sourcee{
\wrd{for} \var{i} \wrd{in} \wrd{range}(20): \\
\hspace*{10mm} \var{a} = \wrd{input}( "Broj tocnih zadataka u prvoj skupini:" ) \\
\hspace*{10mm} \var{b} = \wrd{input}( "Broj tocnih zadataka u drugoj skupini:" ) \\
\hspace*{10mm} \var{c} = \wrd{input}( "Broj tocnih zadataka u trecoj skupini:" ) \\
\hspace*{10mm} \wrd{if} \var{a}+\var{b}+\var{c} $>$= 24: \\
\hspace*{10mm} \hspace*{10mm} \wrd{print} "Polaznik je polozio ispit" \\
\hspace*{10mm} \wrd{else}: \\
\hspace*{10mm} \hspace*{10mm} \wrd{print} "Polaznik nije polozio ispit"
}

Ovaj program funkcionira samo za auto코kole s 20 polaznika, 코ta ako ne znamo
koliko polaznika ima auto코kola?

\sourcee{
\var{n} = \wrd{input}( "Upisi broj polaznika autoskole: )\\
\wrd{for} \var{i} \wrd{in} \wrd{range}(n): \\
\hspace*{10mm} \var{a} = \wrd{input}( "Broj tocnih zadataka u prvoj skupini:" ) \\
\hspace*{10mm} \var{a} = \wrd{input}( "Broj tocnih zadataka u prvoj skupini:" ) \\
\hspace*{10mm} \var{b} = \wrd{input}( "Broj tocnih zadataka u drugoj skupini:" ) \\
\hspace*{10mm} \var{c} = \wrd{input}( "Broj tocnih zadataka u trecoj skupini:" ) \\
\hspace*{10mm} \wrd{if} \var{a}+\var{b}+\var{c} $>$= 24: \\
\hspace*{10mm} \hspace*{10mm} \wrd{print} "Polaznik je polozio ispit" \\
\hspace*{10mm} \wrd{else}: \\
\hspace*{10mm} \hspace*{10mm} \wrd{print} "Polaznik nije polozio ispit"
}

\section{while \dots}

Pomo캖u if-uvjeta i for-petlje se mog rije코iti mnogi problemi koji se
postavljaju pred programera. Ono prvo nam omogu캖uje da ra캜unalo samo
odlu캜uje koje 캖e se naredbe izvr코avati ovisno o nekom uvjetu, a
pomo캖u for-petlje mozemo ponavljati odre캠eni postupak odre캠en broj
puta. Me캠utim, moze nam se desiti da je odre캠eni niz naredbi potrebno
ponavljati nekoliko puta, ali da ne znamo koliko puta treba ponoviti prije nego
코to pokrenemo program. 

While-petlja rje코ava taj problem. Op캖i oblik while-petlje je

\sourcee{
\wrd{while} \emph{logi캜ki izraz}:
\\
\hspace*{10mm}\emph{niz (blok) naredbi}
}

Niz naredbi 캖e se ponavljati sve dok je uvijet istinit. 

Primjer koji ispisuje prvih 10 brojeva:

\sourcee{
\var{n} = 1 \\
\wrd{while} \var{n} $<$= 10: \\
\hspace*{10mm} \wrd{print} "varijabla n je sad", \var{n} \\
\hspace*{10mm} \var{n} = \var{n} + 1
}

Pro캜itajmo 코ta ovaj program trazi od ra캜unala:
\begin{itemize}
	\item Neka $n$ bude jednak 1
	\item Sve dok je $n$ manje od 10 ponavljaj:
	\begin{itemize}
		\item Ispi코i koliki je $n$
		\item Neka $n$ poprimi vrijednost od $n$ uve캖ano za 1.
	\end{itemize}
\end{itemize}

Sve smo to, naravno mogli i s for-petljom. U 캜emu je onda bitna razlika? Razlika
je u tome 코to kod for-petlje na samom po캜etku petlje morate znati koliko
puta 캖e se petlja ponoviti,
\footnote{Postoji na캜in i da se to zaobi캠e pomo캖u "break" i "continue", ali o tome kasnije}
a while petlja mozete pokrenuti tako da se tek negdje tokom njenog izvo캠enja
desi ne코to tako da uvijet kod \verb"while" postane lazan.

Promotrimo npr. zadnji program iz poglavlja o for-petlji; on korektno radi svoj posao
ukoliko instruktor (ili osoba koja ispravlja ispite) zna koliko ima polaznika.
Pretpostavimo sad da instruktor ne zna to캜no koliko je polaznika pisalo ispit, a
ispit se odvija na sljede캖i na캜in: polaznici jedan po jedan ulaze u
instruktorovu kancelariju, kad u캠u on uzima njihov ispit, ispravlja ga i
zeli da mu ra캜unalo na osnovu to캜no rje코enih zadataka iz ispita
kaze za svakog polaznika je li pro코ao ili nije. Instruktor nema vremena
izbrojati koliko je bilo polaznika, pa moze samo primati jednog po jednog
budu캖eg voza캜a, ali nikad ne zna je li on zadnji ili iza njega ima jo코
njih.

Program sad nebi radio jer instruktor na po캜etku programa mora napisati koliko
je bilo ispitanika, a on to ne zna. probati 캖emo to sada rije코iti
pomo캖u while-petlje:

\sourcee{
\textcolor{red}{jos} = "da" \\
\textcolor{blue}{while} \var{jos} != "da": \\
\hspace*{10mm} \textcolor{red}{a} = \textcolor{blue}{input}( "Broj tocnih zadataka u prvoj skupini:" ) \\
\hspace*{10mm} \textcolor{red}{b} = \wrd{input}( "Broj tocnih zadataka u drugoj skupini:" ) \\
\hspace*{10mm} \textcolor{red}{c} = \wrd{input}( "Broj tocnih zadataka u trecoj skupini:" ) \\
\hspace*{10mm} \wrd{if} \var a+\var b+\var c $>$= 24: \\
\hspace*{10mm} \hspace*{10mm} \textcolor{blue}{print} "Polaznik je polozio ispit" \\
\hspace*{10mm} \textcolor{blue}{else}: \\
\hspace*{10mm} \hspace*{10mm} \textcolor{blue}{print} "Polaznik nije polozio ispit" \\
\hspace*{10mm} \textcolor{red}{jos} = \textcolor{blue}{raw\_input}( "Ima li jos polaznika (da/ne) " )
}

Blok naredbi u while-petlji 캖e se ponavljati sve dok je varijabla \verb"jos"
razlicita od "da" (ta varijabla sadrzi string, a ne broj). Kako je na samom
po캜etku njoj pridruzena vrijednost "da" while petlja se po캜ne
izvr코avati, a na samom kraju se od korisnika trazi da upi코e ima li
jo코 polaznika. Ako on upi코e "da"\footnote{Bez navodnika,
naravno} (ili bilo 코ta drugo osim "ne") \verb"jos"
je i dalje razli캜ito od "ne" pa se blok opet izvr코ava. Ukoliko upi코ete
"ne" program zavr코ava svoj posao.

\section{Potprogrami i funkcije}

\subsection{Procedure}

De코ava se da u nekom programu moramo 캜esto ponavljati odre캠eni
niz naredbi. Potprogrami
su strukture u programu koje nam omogu캖uju da odre캠eni niz naredbi
koje se u programu trebaju 캜esto izvr코avati u programu napi코emo
samo jednom.

Slijedi primjer jednostavnog programa koji koristi potprogram:

\sourcee{
\wrd{def} \fun{HelloWorld}():\\
\tab \wrd{print} "Hello world!!! (nalazim se  tijelu potprograma)"\\
\com{\# Ovdje pocinje glavni dio programa}\\
\wrd{print} "Pocetak programa"\\
\fun{HelloWorld}()\\
\fun{HelloWorld}()\\
\wrd{print} "Kraj programa"
}

Rezultat je:

\sourcee{
Pocetak programa \\
Hello world!!! (nalazim se  tijelu funkcije) \\
Hello world!!! (nalazim se  tijelu funkcije) \\
Kraj programa
}

Kad je program pokrenut on nije odmah ispisao poruku iz drugog
reda, ali kasnije, svaki put kad smo upisali HelloWorld() \footnote{Ne
zaboraviti zagrade!!} ispisana je poruka "Hello world!!! (nalazim
se  tijelu funkcije)". Dakle, kao da smo definirali jednu novu
komandu koja ispisuje svoju poruku. 

kad u programu napi코ete "HelloWorld()" kazemo da smo
\textbf{pozvali potprogram} i tada se izvr코avaju komande u \textbf{tijelu
potprograma}. Tijelo potprograma se u na코em primjeru sastoji od samo
jednog retka.

캛emu sluze zagrade iza \verb"HelloWorld"? 

Vratimo se opet na primjer s instruktorom voznje. Zelim sad da
potprogram ispi코e pravu poruku ovisno o tome koliko je polaznik imao
bodova. 

\sourcee{
\wrd{def} \fun{IspisiPoruku}( \var{b} ): \\
\tab \wrd{if} \var{b} $>$= 24: \\
\tab \tab \wrd{print} "Prosli se ispit" \\
\tab \wrd{else}: \\
\tab \tab \wrd{print} "Niste prosli ispit" \\
\\
\fun{IspisiPoruku}( 21 )\\
\fun{IspisiPoruku}( 29 )
}

S retkom "def IspisiPoruku( b ):" po캜inje \textbf{definicija potprograma}.
Budu캖i da smo unutar zagrade iza imena potprograma ("IspisiPoruku")
napisali "b" -- svaki put kad pozovemo potprogram morati 캖emu unutar
zagrade staviti neku vrijednost (varijabla, broj, string). Vrijednost onoga
코to smo upisali u zagradu tamo gdje potprogram pozivamo 캖e u tijelu
potprograma
poprimiti varijabla "b". Kako smo mi upisali "IspisiPoruku( 21 )", u tijelu
캖e varijabla b imati vrijednost 21. A sljede캖i put 캖e
zbg istog razloga varijabla "b" (unutar potprograma) imati vrijednost 29.

Kazemo da je varijabla "b" u zagradi iza definicije potprograma
\textbf{argument potprograma}.

Potprogram moze imati i vi코e argumenata; sljede캖i program
sadrzi potprogram koji ispisuje srednju vrijednost od tri broja i ima
tri argumenta:

\sourcee{
\wrd{def} \fun{SrednjaVrijednost}( \var{a}, \var{b}, \var{c} ):\\
\tab \com{""" Funkcija koja ra캜una srednju vrijednost brojeva a, b i c }\\
\tab \com{ispisuje tu srednju vrijednost """}\\ 
\tab \var{s} = ( \var{a} + \var{b} + \var{c} ) / 3. \\
\tab \com{\# iza 3 moramo smo morali staviti to캜ku, jer ina캜e bi se radilo}\\
\tab \wrd{print} "Srednja vrijednost brojeva", \var{a}, ",", \var{b}, "i", \var{c}, "je", \var{s}\\
\\
\fun{SrednjaVrijednost}( 1, 2, 3 )\\
\var{x} = 2\\
\fun{SrednjaVrijednost}( 4, \var{x}, 7.5 )\\
\fun{SrednjaVrijednost}( \var{x}+1, \var{x}, 1 )\\
\fun{SrednjaVrijednost}( 2*3, 3*3, 4**2 )
}

Program ispisuje:

\sourcee{
Srednja vrijednost brojeva 1 , 2 i 3 je 2.0\\
Srednja vrijednost brojeva 4 , 2 i 7.5 je 4.5\\
Srednja vrijednost brojeva 3 , 2 i 1 je 2.0\\
Srednja vrijednost brojeva 6 , 9 i 16 je 10.3333333333
}

\textbf{Vazno:} Pozeljno je, kao u gornjem primjeru odmah nakon
definicije funkcije napisati jedan komentar (ograni캜enog s """ i """)
koji otprilike opisuje 캜emu sluzi ta funkcija.

Dodajmo sad jo코 jedan uvijet primjeru s instruktorom
voznje;  me캠u polaznicima auto코kole postoje oni koji polazu za
voznju automobila i njima je potrebno 26 boda za prolaz, i postoje oni
koji polazu za voznju mopeda kojima su dovoljna 24 boda za prolaz.
Treba napisati program koji koristi potprogram s 캜etiri argumenta (broj
to캜no rje코enih zadataka u svakoj od tri skupine) i podatak o tome
radi li se o polazniku za moped ili automobil.

\sourcee{
\wrd{def} \fun{IspisiPoruku}( \var{s1}, \var{s2}, \var{s3}, \var{za} ):\\
\tab \com{""" Ispisuje je li polaznik koji je imao:\\
\tab \tab s1 to캜no rje코en zadatak iz prve grupe,\\
\tab \tab s2 to캜no rje코en zadatak iz druge grupe,\\
\tab \tab s3 to캜no rje코en zadatak iz trece grupe\\
\tab ...prosao test.\\
\tab Ako je varijabla 'za' jednaka "auto" onda se racuna kao za\\
\tab polaznika za dozvou za voznju automobila, inace\\
\tab za polaznika voznje s mopedom\\
\tab """}\\
\tab \var{bodovi} = \var{s1} + \var{s2} * 2 + \var{s3} * 3\\
\tab \wrd{if} \var{za} == "auto":\\
\tab \tab \wrd{if} \var{bodovi} $>$= 26:\\
\tab \tab \tab \wrd{print} "Prosli ste"\\
\tab \tab \wrd{else}:\\
\tab \tab \tab \wrd{print} "Niste prosli"\\
\tab \wrd{else}:\\
\tab \tab \wrd{if} \var{bodovi} $>$= 24:\\
\tab \tab \tab \wrd{print} "Prosli ste"\\
\tab \tab \wrd{else}:\\
\tab \tab \tab \wrd{print} "Niste prosli"\\
		\\
\fun{IspisiPoruku}( 5, 4, 4, "auto" )\\
\fun{IspisiPoruku}( 5, 4, 4, "motor" )
}

\subsection{Funkcije}

Funkcija je matemati캜ki pojam; postoje npr. linearne funkcije,
trigonometrijske funkcije, logaritamske funkcije, i tako dalje i
tako blize.

Na primjer, pretpostavimo da imamo funkciju $f(x)=2\cdot x-3$. Tada
je $f(4)=2\cdot 4-3=8-3=5$, a to zna캜i da funkcija $f$ preslikava
broj 4 u broj 5, ili mogli bi re캖i da funkcija f za argument
4 vra캖a 5.

Funkcija se od gornjih potprograma razlikuje u tome 코to funkcija
ima povratnu vrijednost. Rezultat funkcije se moze ispisati,
pridruziti nekoj drugoj varijabli ili s njime ra캜unati. 

Primjer programa koji koristi funkciju:

\sourcee{
\wrd{def} \fun{Zbroji}( \var{a}, \var{b} ):\\
\tab \wrd{return} \var{a} + \var{b}\\
\\
\wrd{print} \fun{Zbroji}( 2, 3 )\\
\wrd{print} \fun{Zbroji}( -3, 3.5 )
}

Definicija funkcije je ista kao i definicija potprograma, jedino 코to
funkcija mora imati neku vrijednost koju vra캖a u glavni program. Kao
코to vidimo ovdje ispisujemo "Zbroj( 2, 3 )", a ono 코to 캖e
ispisati je upravo ona vrijednost koja se vra캖a pomo캖u naredbe
"return".

Ovdje je potrebno jedno malo obja코njenje: U stvari ne postoji razlika
izme캠u potprograma i funkcije. Funkcija \emph{mora} vra캖ati neku
vrijednost pomo캖u "return", ali 캜ak i potprogram koji ne sadrzi
"return" vra캖a vrijednost "None", ali o tome malo vi코e u
sljede캖em poglavlju.

Evo primjer funkcije koja vra캖a zbroj svih brojeva manjih od nekog
zadanog:

\sourcee{
\wrd{def} \fun{ZbrojBrojeva}( \var{n} ):\\
\tab \var{x} = 0\\
\tab \wrd{for} \var{i} \wrd{in} \wrd{range}( \var{n} + 1 ):\\
\tab \tab \var{x} = \var{x} + \var{i}\\
\tab \wrd{return} \var{x}	\\
\\
\wrd{print} \fun{ZbrojBrojeva}( 5 )\\
\var{a} =  \fun{ZbrojBrojeva}( 10 )\\
\var{b} = \fun{ZbrojBrojeva}( 100 )\\
\wrd{print} \var{a} + \var{b} - 100
}

Kao 코to vidite, s vrijedno코캖u koju funkcija vra캖a
mozemo ra캜unati ili tu vrijednost mozemo pridruziti
drugim varijablama.

Vratimo se sad primjeru s instruktorom voznje, taj se program pomo캖u funkcije
mogao napisati ovako:

\sourcee{
\wrd{def} \fun{IspisiPoruku}( \var{s1}, \var{s2}, \var{s3}, \var{za} ): \\
\tab \com{""" Vraca string s porukom je li polaznik koji je imao: \\
\tab  s1 tocno rjesen zadatak iz prve grupe, \\
\tab  s2 tocno rjesen zadatak iz druge grupe, \\
\tab  s3 tocno rjesen zadatak iz trece grupe \\
\tab ...prosao test.  \\
\tab Ako je varijabla 'za' jednaka "auto" onda se racuna kao za \\
\tab polaznika za dozvou za voznju automobila, inace \\
\tab za polaznika voznje s mopedom \\
\tab """} \\
\tab \var{bodovi} = \var{s1} + \var{s2} * 2 + \var{s3} * 3 \\
\tab \wrd{if} \var{za} == "auto": \\
\tab \tab \wrd{if} \var{bodovi} $>$= 26: \\
\tab \tab \tab \var{temp} = "Prosli ste" \\
\tab \tab \wrd{else}: \\
\tab \tab \tab \wrd{temp} = "Niste prosli" \\
\tab \wrd{else}: \\
\tab \tab \wrd{if} \var{bodovi} $>$= 24: \\
\tab \tab \tab \var{temp} = "Prosli ste" \\
\tab \tab \wrd{else}: \\
\tab \tab \tab \var{temp} = "Niste prosli" \\
\tab \wrd{return} \var{temp} \\
\tab \\
\wrd{print} \fun{IspisiPoruku}( 5, 4, 4, "auto" ) \\
\wrd{print} \fun{IspisiPoruku}( 5, 4, 4, "motor" ) 
}

Bitna razlika izme캠u ovog i pro코le verzije ovog programa je u tome 코to je u
pro코lom programu bilo dovoljno napisati npr. "IspisiPoruku( 5, 4, 4, 'motor' )" kao
komandu, a potprogram bi onda ispisao poruku. Sad potprogram samo vra캖a vijrednost
koju onda treba ispisati. 

\subsection{Ugra캠ene funkcije}

\dots

\subsection{Doseg varijabli}

\dots

\section{try}

\dots

\section{break i continue}

\dots

\chapter{Tipovi podataka}

\section{Jednostavni tipovi podataka}

	Varijable u dosada코njim programima se kao vrijednosti imale brojeve, ali
	mogle su sadrzavati i razne druge vrste podataka.

	Ovisno o tome koliko je slozen problem kojeg zelimo rije코iti s
	programom podaci s kojima trebamo raditi mogu biti i vrlo slozeni. Okvirno
	podatke mozemo podijeliti na dva jednostavne i slozene. Slozeni tipovi
	podataka su oni koji u sebi mogu sadr캖avati nekoliko drugih podataka.

	Jednostavni su cjelobrojni tip, realni brojevi i stringovi.

\subsection{Cijeli i realni brojevi}

	Cijeli brojevi su svi prirodni brojevi, nula i brojevi suprotni prirodnim
	brojevima.

	Kad kazemo realni brojevi u programiranju obi캜no mislimo samo na relalne
	brojeve koje mozemo zapisati u s to캜no odre캠enim brojem decimalnih
	mjesta. Za svako ra캜unalo i programski jezik postoje to캜ne granice koliko
	najvie코 decimalnih mjesta mogu sadrz캖avati, koja je najmanja, a koja
	najve캖a mogu캖a brojevna vrijednost koju mozemo koristiti itd.

	\sourcee{
	\var{broj} = 12.13 \textcolor{green}{\# realni broj}\\
	\var{c} = 12 \textcolor{green}{\# cijeli broj}\\
	\var{r} = 12.0 \textcolor{green}{\# realni broj (jer ima decimalnu tocku!)}
	}

	U zadnjem slu캜aju varijabla "r" sadrzava realan broj jer je 12.0
	opisan kao decimalan broj. 

	Realne brojeve mozemo napisati i u "znanstvenom obliku", dakle u obliku $a\cdot
	10^{b}$.

	\vspace{3mm}
	\begin{tabular}{l|l}
		Broj & u Python programu\\
		\hline
		$5\cdot 10^{13}$ & \verb+5e13+\\
		$3.56\cdot 10^{-17}$ & \verb+3.56e-17+\\
	\end{tabular}
	\vspace{3mm}

	Brojevi u heksadecimalnom ili oktalno zapisu i imaginarni brojevi:

	\vspace{3mm}
	\begin{tabular}{l|l|l}
		& Zapis & U programu \\	
		\hline
		Heksadecimalni & 177 & 0177 \\
		\hline
		Oktalni & BAB7& 0xBAB7 \\
		\hline
		Imaginarni & $i$ & 1j \\
		\hline 
		Imaginarni & $0.5i$ & 0.5j \\
		\hline 
		Imaginarni & $2.5+3i$ & 2.5+3j \\
	\end{tabular}
	\vspace{3mm}

	Ukoliko radimo s cjelobrojnim varijablama i veli캜inama, ra캜unalo nam
	postavlja odre캠ene granice. Ne mozemo ra캜unati s \emph{obi캜nim}
	cijeli brojem koji ima 20 znamenaka. Kad nam je zbog nekog slozenog ra캜una
	potrebno raditi s tako veliki brojevima moramo iza samog broja dodati "L"\footnote{Ovo
	"L" moze slobodno biti napisano i malim slovom "l", ali ovdje je napisano "L"
	da se ne bi pomije코alo "l" (malo "l") s "I" (veliko "i")}. Dakle ne
	ne bi napisali 
	
	"a = 128904389523789123789"

	nego\dots

	"a = 128904389523789123789L"

	Probajte oba slu캜aja napisati kao dio jednog va코eg programa i nakon toga
	probati ispisati tu varijablu s "print a" i pogledajte 코to se desilo!

\subsection{Stringovi}

	String je niz znakova proizvoljne duzine. 캛lan stringa moze biti svaki
	simbol kojeg mozete dobiti pritiskom na neku tipku tastature, a i omnogi drugi.
	Stringovi se zapisuju u navodnicima. Dakle primjeri stringova su 
	>>Ovo je string"123"<<, >>'sdjkl'<< ili >>"""String"""<<

\textbf{Zapamtite:} Stringove (nizove znakova) mozemo zapisati
na tri na캜ina: 

	\begin{itemize}
		\item Unutar dvostrukih navodnika -- " 
		\item Unutar jednostrukih navodnika -- '
		\item Ograni캜enih (na po캜etku i na kraju) s nizom od tri dvostruka
			navodnika
	\end{itemize}

	Ponekad 캖e nam trebati da unutar stringa moramo imati neki drugi navodnik. Da
	bi to postigli promotrimo sljede캖i primjer.
	
	\sourcee{
		\var{str} = "Ovo je jedan 'string'"\\
		\textcolor{blue}{print} \var{str}
	}

	Ispisati 캖e

	\sourcee{
		Ovo je jedan 'string'
	}

	Postoji jo코 nekoliko na캜ina:

	\sourcee{
		\var{str} = "Ovo je jedan 'string'" \\
		\textcolor{blue}{print} str \\
		\var{str2} = 'Ovo je jos jedan "string"' \\
		\textcolor{blue}{print} \var{str2} \\
		\var{str3} = \textcolor{green}{"""Ovo je jedan "string" """} \\
		\textcolor{blue}{print} \var{str3} \\
		\var{str4} = "Ovo je jedan $\setminus$"string$\setminus$"" \\
		\textcolor{blue}{print} \var{str4}
	}

	Rezultat nakon pokretanja programa je:

	\sourcee{
		Ovo je jedan 'string' \\
		Ovo je jos jedan "string" \\
		Ovo je jedan "string" \\
		Ovo je jedan "string"
	}

	Dakle, dvostruki navodnik u stringu mozete dobiti tako da string
	ograni캜ite s jednostrukim navodnicima ili s nizom trostrukih navodnika. I,
	postoji jo코 jedan izuzetno vazan na캜in, a to je ono 
	>>str4 = "Ovo je jedan \"string\""<<
	Tamo gdje zelimo da nam se u varijabli nalazi jednostruki ili dvostruki
	navodnik jednostavimo \verb+\"+. Isto tako bi mogli staviti i \verb+\'+. 
	
	Ako recimo zelimo da se na코 string sastoji samo od jednog dvostrukog
	navodnika mozemo napisati \verb+a = "\""+, a ako zelimo da se sastoji od
	znaka \verb+\\+ i " napisali bi \verb+a = "\\\""+ -- prvi i zadnji navodnik su oznake gdje
	po캜inje, a gdje zavr코ava string. Nakon prvog navodnika niz \verb+\\+ zna캜i
	da se tu nalazi simbol \verb+\+, a \verb+\+" je simbol dvostrukog navodnika.
	
	Postoji
	odre캠eni broj znakova i i simbola koje mozemo staviti u string samo
	kombinacijom \verb+\+ i taj znak ili neko slovo:

	{\normalsize
	\begin{tabular}{ll}
		\verb+\+$<$newline$>$ & Ignored \\
		\verb+\\+ & Backslash (\verb+\+) \\
		\verb+\'+ & Jednostruki navodnik (') \\
		\verb+\"+ & Dvostruki navodnik (") \\
		\verb+\a+ & ASCII Bell (BEL)\\
		\verb+\b+ & ASCII Backspace (BS)\\
		\verb+\f+ & ASCII Formfeed (FF)\\
		\verb+\n+ & ASCII Linefeed (LF)\\
		\verb+\N{name}+ & Character named name in the Unicode database (Unicode only)\\
		\verb+\r+ & ASCII Carriage Return (CR)\\
		\verb+\t+ & ASCII Horizontal Tab (TAB)\\
		\verb+\uxxxx+ & Character with 16-bit hex value xxxx (Unicode only)\\
		\verb+\Uxxxxxxxx+ & Character with 32-bit hex value xxxxxxxx (Unicode only)\\
		\verb+\v+ & ASCII Vertical Tab (VT)\\
		\verb+\ooo+ & ASCII character with octal value ooo\\
		\verb+\xhh+ & ASCII character with hex value hh\\
	\end{tabular}
	}

	\vspace{2mm}
Veliku ve캖inu njih mozete slobodno zaboraviti, ali ima
nekoliko njih koje 캖ete 캜esto koristiti: \verb+\<newline>+
(ovdje \verb+<newline>+ predstavlja tipku "enter", "newline" ili
"return"). Interpreter to jednostavno ignorira, 코to je jako
korisno ako imamo string koji je prevelik za jedan red pa ga u
programu zelimo imati napisanog u vi코e redova.

Izuzetno vazna je i kombinacija \verb+\n+ -- kada u string
stavimo tu kombinaciju, pri ispisu stringa 캖e na tom mjestu
ra캜unalo pre캖i u novi red.

	\sourcee{
		\var{a} = "Ovo je jedan $\setminus$"string$\setminus$" koji je $\setminus$ \\
		toliko dug da mi ga je malo nezgodno $\setminus$ \\
		imati u jednom redu, pa sam ga napisao $\setminus$ \\
		u vise redova" \\
		\var{b} = "A, ovo je jedan$\setminus$n$\setminus$n$\setminus$n$\setminus$nhmmm..." \\
		\textcolor{blue}{print} \var{a} \\
		\textcolor{blue}{print} \var{b}
	}

	Sadrzaj stringa a je "Ovo je jedan $\setminus$"string$\setminus$" koji je toliko dug da mi ga je malo nezgodno imati u jednom redu, pa sam ga napisao u vise redova",
	a kad budemo ispisivali varijablu b vidjeti 캖emo 코ta se zbiva s onim
	\verb+\n+ -- svaki put kad ga ra캜unalo "sretne" oti캖i 캖e u novi red.
	Dakle ispisati 캖e "A ovo je jedan" zatim tri puta novi red (dakle tri razmaka
	od jedan red) i onda "hmmmm...".

	Rezultat je dakle:

	\sourcee{
	Ovo je jedan "string" koji je toliko dug da mi ga je malo nezgodno imati u jednom
	\\
	redu, pa sam ga napisao u vise redova
	\\
	A, ovo je jedan
	\\
\ 
	\\
\ 
	\\
\ 
	\\
	hmmm...
	}

Uo캜ite da je ra캜unalo, ipak, string \verb+a+ napisalo u
dva reda i to jednostavno zato 코to mu nije stalo u jedan red.
Da smo imali dovoljno velik monitor bilo bi napisano sve u jednom
redu za razliku od string b u kojemu 캖e uvijek ispisati ona
tri prazna reda upravo zato 코to smo mi eksplicitno tra캖ili
da oni tu budu.

Jo코 samo jedna zadnja napomena. Trebate znati razlikovati
izme캠u \verb+a = 123+ i \verb+a = "123"+. U prvom slu캜aju
varijabla \verb+a+ 캖e sadrzavati \underline{broj} 123 i s
njim mozemo raditi sve ono 코to mozemo raditi s brojevima,
a u drugom slu캜aju varijabla a sadrzava \underline{string}
"123". Sa brojem 123 캖emo mo캖i normalno ra캜unati kao
코to op캖enito mozemo s brojevima, a sa stringom "123"
to ne mozemo.

\subsection{Konverzija tipova}

\dots

\subsection{Varijable i vrste podataka}

Neki programski jezici od programera zahtijevaju da to캜no odredi
kakve 캖e podatke (odnosno vrste podataka) neka varijabla
sadrzavati. Na po캜etku programa se odredi da 캖e npr.
varijabla \verb+x+ sadrzavati samo cijele brojeve, a ako onda
negdje u programu toj varijabli poku코amo pridruziti neki
string ili realan broj, javiti 캖e nam se gre코ka. Za primjer
takvog programskog jezika pogledajte Pascal-program u 1.3.1.  U
Pythonu svaka varijabla moze sadrzavati podatak bilo kojeg
tipa. Ipak, postoje neke dobre programerske navike, a jedna od njih
je da se trudite varijablama . Dakle, ako na po캜etku programa
imate varijablu \verb+n+ koja ima cjelobrojnu vrijednost --
pozeljno je da ta varijabla i dalje u programu sadrzi cijele
brojeve.

\section{Liste}

Jednostavni tipovi podataka kao 코to su brojevi i stringovi
캜esto nisu dovoljni (ili pogodni) za rje코avanje mnogih
problema. Ako imamo neki jako dug program, 캜esto 캖e nam se
desiti da broj varijabli postane prevelik. Pretpostavimo npr. da
imamo program u kojemu se mora raditi s jako velikom koli캜inom
podataka; npr. broj u캜enika neke 코kole.

\dots

\section{Rije캜nici}

\section{Datoteka}

\section{Ostali slozeni tipovi podataka}
\chapter{Moduli}



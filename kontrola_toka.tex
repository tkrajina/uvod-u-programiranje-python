\chapter{Kontrola toka programa}

\section{if \dots then \dots else \dots}

Pretpostavimo da imamo program koji od korisnika trazi da upiše
koliko je bodova zaradio na određenom testu i zatim ovisno o broju
bodova ispisuje koju je ocjenu dobio. Ako je dobio manje ili jednako
39 bodova ocjena je 1, ako ima 40-54 ocjena je 2, za 55-69 ocjena
je 3, za 70-85 ocjena je 4, a za više od 85 ocjenjen je s 5.

Probati ćemo za početak napisati program koji samo ispisuje je
li ocjena 1 ili veća. Za to program treba nekako imati način kako
će provjeriti je li broj bodova veći, manji ili jednak 40.

Program izgleda ovako:

\sourcee{
\var{bodovi} = \wrd{input}( "Upiši broj bodova:" )
\\
\wrd{print} "Imate", bodovi, "bodova..."
\\
\wrd{if} \var{bodovi} $<$ 40:
\\
\hspace*{10mm}\wrd{print} "Nazalost dobili ste negativnu ocjenu :("
\\
\wrd{print} "Kraj programa"
}

Korištena je naredba if, ona se koristi na sljedeći način:

\sourcee{
\wrd{if} \emph{logički izraz}:
\\
\hspace*{10mm}\emph{komande programa u slučaju da je logički izraz istinit}
}

Kao prvo uočite da je dio programa koji seizvršava u slučaju da
je logički izraz istinit \emph{uvučen} u odnosu na ostatak
programa. To uvlačenje je točno definirano i mora biti jedan
$<$tab$>$ (ili 8 razmaknica) računajući od lijevog ruba polja u kojem se
editira program!

U početnom programu se komanda nakon \verb"if" naredbe izvršava
jedino u slučaju ako je broj bodova manji od 40, ako je broj bodova
veći ili jednak 40 program tu liniju jednostavno preskače. Mozemo
srediti i da program preskače veći broj linija:

\sourcee{
\var{bodovi} = \wrd{input}( "Upiši broj bodova:" )
\\
\wrd{print} "Imate", bodovi, "bodova..."
\\
\wrd{if} \var{bodovi} $<$ 40:
\\
\hspace*{10mm}
	\wrd{print} "Nazalost dobili ste negativnu ocjenu :("
\\
\hspace*{10mm}
	\wrd{print} "Molimo vas lijepo da za sljedeći put malo bolje naučite"
\\
\wrd{print} "Kraj programa"
}

Poruka koja se sad ispisuje ukoliko nemate dovoljno bodova je 

\sourcee{
Nazalost dobili ste negativnu ocjenu :(
\\
Molimo vas lijepo da za sljedeći put malo bolje naučite
}

Opet, \verb"Kraj programa" se ispisuje bez obzira na broj bodova.

Zelimo li da naš program ispisuje i poruku ukoliko imate više ili jednako od 40 bodova to se moze
tako da koristite dva puta naredbu \verb"if":

\sourcee{
\var{bodovi} = \wrd{input}( "Upiši broj bodova:" )
\\
\wrd{print} "Imate", bodovi, "bodova..."
\\
\wrd{if} \var{bodovi} $<$ 40:
\\
\hspace*{10mm}
	\wrd{print} "Nazalost dobili ste negativnu ocjenu :("
\\
\wrd{if} \var{bodovi} $>$= 40:
\\
\hspace*{10mm}
	\wrd{print} "Imate više od 40 bodova"
\\
\wrd{print} "Kraj programa"
}

Ili pomoću jednog dodatka naredbi \verb"if":

\sourcee{
\var{bodovi} = \wrd{input}( "Upiši broj bodova:" )
\\
\wrd{print} "Imate", bodovi, "bodova..."
\\
\wrd{if} \var{bodovi} $<$ 40:
\\
\hspace*{10mm}
	\wrd{print} "Nazalost dobili ste negativnu ocjenu :("
\\
\wrd{else}:
\\
\hspace*{10mm}
	\wrd{print} "Imate više od 40 bodova"
\\
\wrd{print} "Kraj programa"
}

Program govori računalu:
\emph{Ako je broj bodova manji od 40 tada ste dobili negativnu
ocjenu, inače imate više od 40 bodova}

Sve ono što se nalazi nakon \verb"else", naravno uvučeno za jedan
$<$tab$>$ će biti ispisano u slučaju da uvjet \verb"bodovi$<$40" nije
istinit!

Sta ako ne zelimo samo podatak o tome jesmo li dobili više ili
manje od 40 bodova nego i koju smo ocjenu dobili:

Prvi način koristeći niz \verb"if"-ova:

\sourcee{
\var{bodovi} = \wrd{input}( "Upiši broj bodova:" )
\\
\wrd{print} "Imate", bodovi, "bodova..."
\\
\wrd{if} \var{bodovi} $<$ 40:
\\
\hspace*{10mm}
	\wrd{print} "Nazalost dobili ste negativnu ocjenu :("
\\
\wrd{if} 40$<$=\var{bodovi} and \var{bodovi}$<$=54:
\\
\hspace*{10mm}
	\wrd{print} "Dovoljan (2)"
\\
\wrd{if} 55$<$=\var{bodovi} and \var{bodovi}$<$=69:
\\
\hspace*{10mm}
	\wrd{print} "Dobar (3)"
\\
\wrd{if} 70$<$=\var{bodovi} and \var{bodovi}$<$=84:
\\
\hspace*{10mm}
	\wrd{print} "Vrlo dobar (4)"
\\
\wrd{if} 85$<$=\var{bodovi}:
\\
\hspace*{10mm}
	\wrd{print} "Odličan (5)"
}

Drugi način koristeći \verb"elif" (od eng. "else if"):

\sourcee{
\var{bodovi} = \var{input}( "Upiši broj bodova:" )
\\
\wrd{print} "Imate", \var{bodovi}, "bodova..."
\\
\wrd{if} \var{bodovi} $<$ 40:
\\
\hspace*{10mm}
	\wrd{print} "Nazalost dobili ste negativnu ocjenu :("
\\
\wrd{elif} 40$<$=\var{bodovi} and \var{bodovi}$<$=54:
\\
\hspace*{10mm}
	\wrd{print} "Dovoljan (2)"
\\
\wrd{elif} 55$<$=\var{bodovi} and \var{bodovi}$<$=69:
\\
\hspace*{10mm}
	\wrd{print} "Dobar (3)"
\\
\wrd{elif} 70$<$=\var{bodovi} and \var{bodovi}$<$=84:
\\
\hspace*{10mm}
	\wrd{print} "Vrlo dobar (4)"
\\
\wrd{elif} 85$<$=\var{bodovi}:
\\
\hspace*{10mm}
	\wrd{print} "Odličan (5)"
}

Na hrvatskom bi ovo napisali: \emph{Ako imate manje od 40 bodova dobili ste 2, inače ukoliko imate
između 40 i 54 dobili ste 2, inače ukoliko imate između 55 i 59 dobili ste 3, inače ukoliko imate
između 70 i 84 dobili ste 4, inače ukoliko imate više od 84 dobili ste 5}.

Mali problem moze nastati u tome što mozete napisati i 120 ili -340 za broj bodova. Probajmo
napisati program koji ispravlja tu grešku:

\sourcee{
\var{bodovi} = \wrd{input}( "Upiši broj bodova:" ) \\
\wrd{print} "Imate", \var{bodovi}, "bodova..." \\
\wrd{if} 0$<$= \var{bodovi} and \var{bodovi} $<$ 40: \\
\hspace*{10mm} \wrd{print} "Nazalost dobili ste negativnu ocjenu :(" \\
\wrd{elif} 40$<$=\var{bodovi} and \var{bodovi}$<$=54: \\
\hspace*{10mm} \wrd{print} "Dovoljan (2)" \\
\wrd{elif} 55$<$=\var{bodovi} and \var{bodovi}$<$=69: \\
\hspace*{10mm} \wrd{print} "Dobar (3)" \\
\wrd{elif} 70$<$=\var{bodovi} and \var{bodovi}$<$=84: \\
\hspace*{10mm} \wrd{print} "Vrlo dobar (4)" \\
\wrd{elif} 85$<$=\var{bodovi} and \var{bodovi} $<$=100: \\
\hspace*{10mm} \wrd{print} "Odličan (5)" \\
\wrd{else}: \\
\hspace*{10mm} \wrd{print} "Niste upisali broj između 0 i 100 za broj bodova"
}

Sad bi "prijevod" ovog programa na hrvatski glasio: \emph{Ako imate
između 0 i 40 bodova dobili ste 2, inače ukoliko imate između
40 i 54 dobili ste 2, inače ukoliko imate između 55 i 59 dobili
ste 3, inače ukoliko imate između 70 i 84 dobili ste 4, inače
ukoliko imate između 84 i 100 dobili ste 5, a ako nije niti jedan
od ovih slučajeva onda ste pogrešno upsali broj bodova}.

Zadaci: \textbf{Za napraviti}

\section{for \dots in range( \dots )}

Problem je sljedeći; treba ispisati tablicu kvadrata brojeva od do 10.
Tablica kvadrata je tablica koja ima dva stupca, u prvom se nalazeprirodni
brojevi, a u drugom njihovi kvadrati (da podsjetimo, kvadrat prirodnog
broja dobijemo tako da taj broj pomnozimo sa samim sobom).

To se moze postići na sljedeći način:

\sourcee{
\wrd{print} "n -$>$ n*n" \\
\wrd{print} 1, " -$>$ ", 1**2 \\
\wrd{print} 2, " -$>$ ", 2**2 \\
\wrd{print} 3, " -$>$ ", 3**2 \\
\wrd{print} 4, " -$>$ ", 4**2 \\
\wrd{print} 5, " -$>$ ", 5**2 \\
\wrd{print} 6, " -$>$ ", 6**2 \\
\wrd{print} 7, " -$>$ ", 7**2 \\
\wrd{print} 8, " -$>$ ", 8**2 \\
\wrd{print} 9, " -$>$ ", 9**2 \\
\wrd{print} 10, " -$>$ ", 10**2
}

\verb"5**2" znači $5^2$. U svakom retku se naredbom print ispisuje broj i
njegov kvadrat. 

Međutim, ovo je jedan prilično \emph{neelegantan} način rješavanja
problema, a to zato što je ovakav program teško generalizirati,
odnosno teško ga je upotrijebiti u slučaju da njime moramo
riješiti neki analogni ili opcehnitiji problem. 
\footnote{
	Ako je naš trenutni
	problem \emph{"Napiši program koji ispisuje tablicku kvadrata
	prvih 10 brojeva"} analogni (ali slozeniji) problem moze glasiti
	\emph{"Napiši program koji ispisuje tablicu kvadrata za brojeve
	od 0 do 100"}. Općenitiji problem bi mogao biti \emph{"Napiši
	program koji ispisuje tablicu kvadrata za brojeve od 0 do n (gdje
	je n proizvoljan prirodan broj)"}. 
}
Taj program se moze napisati
na način slučan našem načinu, ali priznati ćete da pisanje
sto i jedne linije tipa s naredbom \verb"print" koja ne radi ništa
drugo negoli ispisuje broj i njegov kvadrat i nije neki pretjerano
kreativan posao.

Zato postoji nareda \verb"for". Ta naredba od računala trazi da
određeni broj puta ponovi neki postupak uz određene uvjete. Uz
naredbu \verb"for" se nalazi ime varijable i nekakav \emph{skupa}
ili \emph{lista} prema kojima se ta varijabla "kreće". Budući da
će se ova skripta baviti skupovima, listama i ostalim slozenim
tipovima podataka baviti tek kasnije ovdje ću objasniti samo jedan
od načina koji se često koriste s naredbom \verb"for".

\sourcee{
\wrd{print} "n -$>$ n*n" \\
\wrd{for} \var{x} \wrd{in} \wrd{range}(11): \\
\tab \wrd{print} \var{x}, " -$>$ ", \var{x}**2
}

Rezultat programa će biti potpuno isti kao i kod prošlog programa.

Druga i treća linija ovog programa kaze otprilike: \emph{"Neka
varijabla x uzima redom vrijednost 0, 1, 2\dots sve dok je manje
od 11, i za svaku od tih vrijednosti ispiši vrijednost od x i
kvadrat od x"}. Nakon što python interpreter dođe do druge linije
programa računalo samo varijabli x pridodaje vrijednost 0, i
izvršava treću liniju programa (x je tamo 0). Nakon što to
izvrši varijabli x se pridruzuje sljedeća vrijednost; 1. Sad se
opet ispisuje treća linija programa, ali s novom vrijednosću
varijeble x. Nakon toga x poprima vrijednost 2, izvršava se treća
linija, i tako dalje\dots

\textbf{Vazno:}
Nikad ne zaboravite dvotočku iza "for" linije -- to je naime vrlo
česta početnička greška.

\textbf{Definicija:} Za liniju s \verb"for" naredbom i niz naredbi koje
se izvršavaju pri svakoj promjeni varijable nakon \verb"for"
kazemo da se zovu \textbf{for-petlja}. Ukoliko je \verb"x" varijabla
nakon \verb"for" kazemo da smo izvršili \textbf{for-petlju po varijabli
x}. Svaki put kad varijabla \verb"x" promijeni vrijednost zbog \verb"for"
petlje kazemo da je izvršeno \textbf{iteracija}. Niz naredbi koje se
izvršavaju u svakoj iteraciji zovemi tijelo for-petlje.

Isto tako, mozete srediti da se izvršava i više linija svaki
put kad varijabla x u zbog \verb"for" mijenja vrijednost. Jednostavno
nakon trećeg reda programa napisali biste još jedan, ali i taj
obavezno mora biti pomaknuti za jedan $<$tab$>$ udesno.

Pretpostavimo sad da treba napisati prgram koji od koristnika trazi
da mu upiše jedan broj, a zatim ispisuje prvo kvadrat tog broja,
a onda rezultat pri cjelobrojnom dijeljenju 
\footnote{
	Cjelobrojno dijeljenje znači da se radi o dijeljenju u
	kojemu se ignorira dio iza decimalne točke u rezultatu
	nekog dijeljenja. Npr ukoliko podijelimo 7 sa 4 dobiti
	ćemo 1.75, ali rezultat cjelobrojnog dijeljenja 7 sa 4 je
	1. Podsjetimo da python vrši cjelobrojno dijeljenje ukoliko
	su djeljenik i djelitelj cijeli brojevi (nemaju decimalnog
	dijela).
}
tog broja s 2.

\sourcee{
\var{n} = \wrd{input}( "Upiši broj:" )
\\
\wrd{for} \var{i} \wrd{in} \wrd{range}( \var{n}+1 ):
\\
\hspace*{10mm}
	\wrd{print} "kvadrat od", \var{i}, "je", \var{i}**2
\\
\hspace*{10mm}
	\wrd{print} "rezultat cjelobrojnog dijeljenja od", \var{i}, "s 2 je", \var{i}/2
\\
\wrd{print} "Kraj programa"
}

Ovdje se tijelo for-petlje sastoji od dvije naredbe (treći i
četvrti red programa. Zadnja linija ne spada u tijelo petlje jer
se ne izvršava kod svake iteracije nego samo jednom nakon što se
cijela petlja "izvrši".

Prvo se varijabli \verb"n" pridjeljuje vrijednost koju upisuje
osoba koja pokreće program. Zatim se vrši petlja po varijabli
\verb"i". Obratite paznju da se petlja sad kreće u granicama od
0, pa po svim cijelim brojevima manjim od \verb"n+1", a najveći
cijeli broj manji od \verb"n+1" je \verb"n". Dakle petlja se ne
izvrašava za \verb"n+1" nego samo do \verb"n", a to je upravo ono
što mi zelimo.

Zelimo sad program koji će za svaki broj od 0 do 100 ispisati
njegov kvadrat i, ukoliko je taj broj paran ispisati i poruku o
tome. Broj je paran u koliko je rezultati pri dijeljenju tog broja
s 2 jednak s 0. Rezultat pri dijeljenju dobijemo pomoću operacije
modulo (\verb"%" u python programu)

\sourcee{
\wrd{for} \var{x} \wrd{in} \wrd{range}(101): \\
\tab \wrd{print} \var{x}, "na kvadrat iznosi", \var{x}**2 \\
\tab \wrd{if} \var{x} \% 2 == 0: \\
\tab \wrd{print} \var{x}, "je paran broj" \\
\wrd{print} "Kraj programa"
}

\textbf{Komentar:} Tijelo for-petlje koja počinje s prvim redom
programa je niz naredbi koji se sastoji od 2-4 linije programa.
Obratite paznju da je ovdje 4. linija, koja se izvršava jedino
kad je istinit sud \verb"x%2==0" pomaknuta za \emph{dva} $<$tab$>$-a!
Za svaki \verb"x" if-uvjet isprobava je li istina da je rezultat
pri djeljenju x s 2 jednak 0 (\verb"x%2==0"), a ako je to istina
izvršava se 4. linija.

Evo još jedna varijanta programa:
\footnote{
Zbog lakšeg opisivanja programa ovdje je na početku svakog retka
ispisan i redni broj tog reda. Kad prepisivanja programa u editoru to n
prepisujete.
}

\sourcee{
1: \wrd{for} \var{x} \wrd{in} \wrd{range}(101): \\
2:\tab \wrd{print} \var{x}, "na kvadrat iznosi", \var{x}**2 \\
3:\tab \wrd{if} \var{x} \% 2 == 0: \\
4:\tab \tab \wrd{print} \var{x}, "je paran broj" \\
5:\tab \wrd{else}: \\
6:\tab \tab \wrd{print} \var{x}, "nije paran broj" \\
7:\tab \wrd{print} \\
8: \wrd{print} "Kraj programa"
}

U čemu se ona razlikuje od gornjeg programa? Probajte sami otkriti šta
radi sedma linija programa? Ovisi li njeno izvršavanje o tome je li
izvršen uvjet u 3. redu? Probajte promijeniti program tako da se petlja ne
izvršava za brojeve do 100 nego da korisnik moze sam odrediti do kojeg do
kojeg broja se petlja izvršava.

Probajte objasniti zašto donji program radi potpuno istu stvar
kao i naš zadnji program:\footnote{Pomoć: svaki broj je po definiciji sud
čija istinitost ovisi o\dots}

\sourcee{
1: \wrd{for} \var{x} \wrd{in} \wrd{range}(101): \\
2: \tab \wrd{print} \var{x}, "na kvadrat iznosi", \var{x}**2 \\
3: \tab \wrd{if} \wrd{not} \var{x} \% 2: \\
4: \tab \tab \wrd{print} \var{x}, "je paran broj" \\
5:	\tab \wrd{else}: \\
6: \tab\tab \var{x}, "nije paran broj" \\
7: \tab \wrd{print} \\
8: \wrd{print} "Kraj programa"
}

Još jedna korisna varijanta varijanta for-petlja s \verb"range(...)" je
slučaj u kojem ne zelim da se petlja izvršava za brojeve od 0 do nekog
broja nego od nekog broja različitog od 0 do nekog drugog broja:

\sourcee{
\wrd{for} \var{i} \wrd{in} \wrd{range}( 15, 70 ):\\
\hspace*{10mm} \wrd{print} \var{i}
}

Ispisati će brojeve od 15 do 70.

Probajte objasniti šta radi sljedeći program:

\sourcee{
\var{a} = \wrd{input}( "Upiši prvi broj:" ) \\
\var{b} = \wrd{input}( "Upiši prvi broj:" ) \\
\wrd{if} \var{a} $<$ \var{b}: \\
\hspace*{10mm} \wrd{for} \var{x} \wrd{in} \wrd{range}( \var{a}, \var{b} + 1 ): \\
\hspace*{10mm} \hspace*{10mm} \wrd{print} \var{x}, "na treću iznosi", \var{x}**3 \\
\wrd{else}: \\
\hspace*{10mm} \wrd{print} "hmmm..."
}

Napišite sada program koji od korisnika trazi da upiše dva broja, a
zatim ispisuje tablicu kvadrata svh brojeva od prvog do drugog.

Evo još jedan zanimljiv program koji ispisuje tablicu mnozenja brojeva od
1 do 10. Treba dakle napisati sve izraze oblika $a\cdot b$ gdje $a$ i $b$
mogu biti brojevi od 1 do 10. Ali (!) za svaki $a$ od 1 do 10 (for-petlja)
i $b$ mora moći poprimiti vrijednosti od 1 do 10.

\sourcee{
\wrd{for} \var{a} \wrd{in} \wrd{range}(1, 11): \\
\hspace*{10mm} \wrd{for} \var{b} \wrd{in} \wrd{range}(1, 11): \\
\hspace*{10mm} \hspace*{10mm} \wrd{print} \var{a}, "puta", \var{b}, "je jednako", \var{a}*\var{b}
}

Tijelo prve petlje je drugi i treći red, a tijelo druge petlje je samo
treći red. Dakle, za svaki a od 1 do 10 izvršiti će se druga petlja u
kojoj se sad b mijenja od 1 do 10 i kod svake promjene ispisuje poruka.

Još jedan primjer:

Pretpostavimo da imamo ovakav problem:
Polaznik jedne autoškole polazu pismeni dio vozačkog ispita.
Ispit se sastoji od 15 pitanja koji su podijeljeni u tri skupine po 5 zadatka.
Zadaci iz prve skupine nose po 1 bod, iz druge skupine 2 boda, a iz treće
skupine po 3 boda. Za prolaz na ispitu potrebno je da polaznik ima barem 24 boda.
Treba napisati program koji od instruktora trazi da upiše broj točnih
zadataka iz prve, druge i treće skupine i onda ispisuje je li polaznik
autoškole zadovoljio uvjete.

Program bi mogao izgledati ovako:

\sourcee{
\var{a} = \wrd{input}( "Broj tocnih zadataka u prvoj skupini:" ) \\
\wrd{b} = \wrd{input}( "Broj tocnih zadataka u drugoj skupini:" ) \\
\var{c} = \wrd{input}( "Broj tocnih zadataka u trecoj skupini:" ) \\
\wrd{if} \var{a}+\var{b}+\var{c} $>$= 24: \\
\hspace*{10mm} \wrd{print} "Polaznik je polozio ispit" \\
\wrd{else}: \\
\hspace*{10mm} \wrd{print} "Polaznik nije polozio ispit"
}

Ukoliko znamo da ta autoškola ima 20 polaznika mozemo srediti da program
radi za sve polaznike autoškole:

\sourcee{
\wrd{for} \var{i} \wrd{in} \wrd{range}(20): \\
\hspace*{10mm} \var{a} = \wrd{input}( "Broj tocnih zadataka u prvoj skupini:" ) \\
\hspace*{10mm} \var{b} = \wrd{input}( "Broj tocnih zadataka u drugoj skupini:" ) \\
\hspace*{10mm} \var{c} = \wrd{input}( "Broj tocnih zadataka u trecoj skupini:" ) \\
\hspace*{10mm} \wrd{if} \var{a}+\var{b}+\var{c} $>$= 24: \\
\hspace*{10mm} \hspace*{10mm} \wrd{print} "Polaznik je polozio ispit" \\
\hspace*{10mm} \wrd{else}: \\
\hspace*{10mm} \hspace*{10mm} \wrd{print} "Polaznik nije polozio ispit"
}

Ovaj program funkcionira samo za autoškole s 20 polaznika, šta ako ne znamo
koliko polaznika ima autoškola?

\sourcee{
\var{n} = \wrd{input}( "Upisi broj polaznika autoskole: )\\
\wrd{for} \var{i} \wrd{in} \wrd{range}(n): \\
\hspace*{10mm} \var{a} = \wrd{input}( "Broj tocnih zadataka u prvoj skupini:" ) \\
\hspace*{10mm} \var{a} = \wrd{input}( "Broj tocnih zadataka u prvoj skupini:" ) \\
\hspace*{10mm} \var{b} = \wrd{input}( "Broj tocnih zadataka u drugoj skupini:" ) \\
\hspace*{10mm} \var{c} = \wrd{input}( "Broj tocnih zadataka u trecoj skupini:" ) \\
\hspace*{10mm} \wrd{if} \var{a}+\var{b}+\var{c} $>$= 24: \\
\hspace*{10mm} \hspace*{10mm} \wrd{print} "Polaznik je polozio ispit" \\
\hspace*{10mm} \wrd{else}: \\
\hspace*{10mm} \hspace*{10mm} \wrd{print} "Polaznik nije polozio ispit"
}

\section{while \dots}

Pomoću if-uvjeta i for-petlje se mog riješiti mnogi problemi koji se
postavljaju pred programera. Ono prvo nam omogućuje da računalo samo
odlučuje koje će se naredbe izvršavati ovisno o nekom uvjetu, a
pomoću for-petlje mozemo ponavljati određeni postupak određen broj
puta. Međutim, moze nam se desiti da je određeni niz naredbi potrebno
ponavljati nekoliko puta, ali da ne znamo koliko puta treba ponoviti prije nego
što pokrenemo program. 

While-petlja rješava taj problem. Opći oblik while-petlje je

\sourcee{
\wrd{while} \emph{logički izraz}:
\\
\hspace*{10mm}\emph{niz (blok) naredbi}
}

Niz naredbi će se ponavljati sve dok je uvijet istinit. 

Primjer koji ispisuje prvih 10 brojeva:

\sourcee{
\var{n} = 1 \\
\wrd{while} \var{n} $<$= 10: \\
\hspace*{10mm} \wrd{print} "varijabla n je sad", \var{n} \\
\hspace*{10mm} \var{n} = \var{n} + 1
}

Pročitajmo šta ovaj program trazi od računala:
\begin{itemize}
	\item Neka $n$ bude jednak 1
	\item Sve dok je $n$ manje od 10 ponavljaj:
	\begin{itemize}
		\item Ispiši koliki je $n$
		\item Neka $n$ poprimi vrijednost od $n$ uvećano za 1.
	\end{itemize}
\end{itemize}

Sve smo to, naravno mogli i s for-petljom. U čemu je onda bitna razlika? Razlika
je u tome što kod for-petlje na samom početku petlje morate znati koliko
puta će se petlja ponoviti,
\footnote{Postoji način i da se to zaobiđe pomoću "break" i "continue", ali o tome kasnije}
a while petlja mozete pokrenuti tako da se tek negdje tokom njenog izvođenja
desi nešto tako da uvijet kod \verb"while" postane lazan.

Promotrimo npr. zadnji program iz poglavlja o for-petlji; on korektno radi svoj posao
ukoliko instruktor (ili osoba koja ispravlja ispite) zna koliko ima polaznika.
Pretpostavimo sad da instruktor ne zna točno koliko je polaznika pisalo ispit, a
ispit se odvija na sljedeći način: polaznici jedan po jedan ulaze u
instruktorovu kancelariju, kad uđu on uzima njihov ispit, ispravlja ga i
zeli da mu računalo na osnovu točno rješenih zadataka iz ispita
kaze za svakog polaznika je li prošao ili nije. Instruktor nema vremena
izbrojati koliko je bilo polaznika, pa moze samo primati jednog po jednog
budućeg vozača, ali nikad ne zna je li on zadnji ili iza njega ima još
njih.

Program sad nebi radio jer instruktor na početku programa mora napisati koliko
je bilo ispitanika, a on to ne zna. probati ćemo to sada riješiti
pomoću while-petlje:

\sourcee{
\textcolor{red}{jos} = "da" \\
\textcolor{blue}{while} \var{jos} != "da": \\
\hspace*{10mm} \textcolor{red}{a} = \textcolor{blue}{input}( "Broj tocnih zadataka u prvoj skupini:" ) \\
\hspace*{10mm} \textcolor{red}{b} = \wrd{input}( "Broj tocnih zadataka u drugoj skupini:" ) \\
\hspace*{10mm} \textcolor{red}{c} = \wrd{input}( "Broj tocnih zadataka u trecoj skupini:" ) \\
\hspace*{10mm} \wrd{if} \var a+\var b+\var c $>$= 24: \\
\hspace*{10mm} \hspace*{10mm} \textcolor{blue}{print} "Polaznik je polozio ispit" \\
\hspace*{10mm} \textcolor{blue}{else}: \\
\hspace*{10mm} \hspace*{10mm} \textcolor{blue}{print} "Polaznik nije polozio ispit" \\
\hspace*{10mm} \textcolor{red}{jos} = \textcolor{blue}{raw\_input}( "Ima li jos polaznika (da/ne) " )
}

Blok naredbi u while-petlji će se ponavljati sve dok je varijabla \verb"jos"
razlicita od "da" (ta varijabla sadrzi string, a ne broj). Kako je na samom
početku njoj pridruzena vrijednost "da" while petlja se počne
izvršavati, a na samom kraju se od korisnika trazi da upiše ima li
još polaznika. Ako on upiše "da"\footnote{Bez navodnika,
naravno} (ili bilo šta drugo osim "ne") \verb"jos"
je i dalje različito od "ne" pa se blok opet izvršava. Ukoliko upišete
"ne" program završava svoj posao.

\section{Potprogrami i funkcije}

\subsection{Procedure}

Dešava se da u nekom programu moramo često ponavljati određeni
niz naredbi. Potprogrami
su strukture u programu koje nam omogućuju da određeni niz naredbi
koje se u programu trebaju često izvršavati u programu napišemo
samo jednom.

Slijedi primjer jednostavnog programa koji koristi potprogram:

\sourcee{
\wrd{def} \fun{HelloWorld}():\\
\tab \wrd{print} "Hello world!!! (nalazim se  tijelu potprograma)"\\
\com{\# Ovdje pocinje glavni dio programa}\\
\wrd{print} "Pocetak programa"\\
\fun{HelloWorld}()\\
\fun{HelloWorld}()\\
\wrd{print} "Kraj programa"
}

Rezultat je:

\sourcee{
Pocetak programa \\
Hello world!!! (nalazim se  tijelu funkcije) \\
Hello world!!! (nalazim se  tijelu funkcije) \\
Kraj programa
}

Kad je program pokrenut on nije odmah ispisao poruku iz drugog
reda, ali kasnije, svaki put kad smo upisali HelloWorld() \footnote{Ne
zaboraviti zagrade!!} ispisana je poruka "Hello world!!! (nalazim
se  tijelu funkcije)". Dakle, kao da smo definirali jednu novu
komandu koja ispisuje svoju poruku. 

kad u programu napišete "HelloWorld()" kazemo da smo
\textbf{pozvali potprogram} i tada se izvršavaju komande u \textbf{tijelu
potprograma}. Tijelo potprograma se u našem primjeru sastoji od samo
jednog retka.

Čemu sluze zagrade iza \verb"HelloWorld"? 

Vratimo se opet na primjer s instruktorom voznje. Zelim sad da
potprogram ispiše pravu poruku ovisno o tome koliko je polaznik imao
bodova. 

\sourcee{
\wrd{def} \fun{IspisiPoruku}( \var{b} ): \\
\tab \wrd{if} \var{b} $>$= 24: \\
\tab \tab \wrd{print} "Prosli se ispit" \\
\tab \wrd{else}: \\
\tab \tab \wrd{print} "Niste prosli ispit" \\
\\
\fun{IspisiPoruku}( 21 )\\
\fun{IspisiPoruku}( 29 )
}

S retkom "def IspisiPoruku( b ):" počinje \textbf{definicija potprograma}.
Budući da smo unutar zagrade iza imena potprograma ("IspisiPoruku")
napisali "b" -- svaki put kad pozovemo potprogram morati ćemu unutar
zagrade staviti neku vrijednost (varijabla, broj, string). Vrijednost onoga
što smo upisali u zagradu tamo gdje potprogram pozivamo će u tijelu
potprograma
poprimiti varijabla "b". Kako smo mi upisali "IspisiPoruku( 21 )", u tijelu
će varijabla b imati vrijednost 21. A sljedeći put će
zbg istog razloga varijabla "b" (unutar potprograma) imati vrijednost 29.

Kazemo da je varijabla "b" u zagradi iza definicije potprograma
\textbf{argument potprograma}.

Potprogram moze imati i više argumenata; sljedeći program
sadrzi potprogram koji ispisuje srednju vrijednost od tri broja i ima
tri argumenta:

\sourcee{
\wrd{def} \fun{SrednjaVrijednost}( \var{a}, \var{b}, \var{c} ):\\
\tab \com{""" Funkcija koja računa srednju vrijednost brojeva a, b i c }\\
\tab \com{ispisuje tu srednju vrijednost """}\\ 
\tab \var{s} = ( \var{a} + \var{b} + \var{c} ) / 3. \\
\tab \com{\# iza 3 moramo smo morali staviti točku, jer inače bi se radilo}\\
\tab \wrd{print} "Srednja vrijednost brojeva", \var{a}, ",", \var{b}, "i", \var{c}, "je", \var{s}\\
\\
\fun{SrednjaVrijednost}( 1, 2, 3 )\\
\var{x} = 2\\
\fun{SrednjaVrijednost}( 4, \var{x}, 7.5 )\\
\fun{SrednjaVrijednost}( \var{x}+1, \var{x}, 1 )\\
\fun{SrednjaVrijednost}( 2*3, 3*3, 4**2 )
}

Program ispisuje:

\sourcee{
Srednja vrijednost brojeva 1 , 2 i 3 je 2.0\\
Srednja vrijednost brojeva 4 , 2 i 7.5 je 4.5\\
Srednja vrijednost brojeva 3 , 2 i 1 je 2.0\\
Srednja vrijednost brojeva 6 , 9 i 16 je 10.3333333333
}

\textbf{Vazno:} Pozeljno je, kao u gornjem primjeru odmah nakon
definicije funkcije napisati jedan komentar (ograničenog s """ i """)
koji otprilike opisuje čemu sluzi ta funkcija.

Dodajmo sad još jedan uvijet primjeru s instruktorom
voznje;  među polaznicima autoškole postoje oni koji polazu za
voznju automobila i njima je potrebno 26 boda za prolaz, i postoje oni
koji polazu za voznju mopeda kojima su dovoljna 24 boda za prolaz.
Treba napisati program koji koristi potprogram s četiri argumenta (broj
točno rješenih zadataka u svakoj od tri skupine) i podatak o tome
radi li se o polazniku za moped ili automobil.

\sourcee{
\wrd{def} \fun{IspisiPoruku}( \var{s1}, \var{s2}, \var{s3}, \var{za} ):\\
\tab \com{""" Ispisuje je li polaznik koji je imao:\\
\tab \tab s1 točno rješen zadatak iz prve grupe,\\
\tab \tab s2 točno rješen zadatak iz druge grupe,\\
\tab \tab s3 točno rješen zadatak iz trece grupe\\
\tab ...prosao test.\\
\tab Ako je varijabla 'za' jednaka "auto" onda se racuna kao za\\
\tab polaznika za dozvou za voznju automobila, inace\\
\tab za polaznika voznje s mopedom\\
\tab """}\\
\tab \var{bodovi} = \var{s1} + \var{s2} * 2 + \var{s3} * 3\\
\tab \wrd{if} \var{za} == "auto":\\
\tab \tab \wrd{if} \var{bodovi} $>$= 26:\\
\tab \tab \tab \wrd{print} "Prosli ste"\\
\tab \tab \wrd{else}:\\
\tab \tab \tab \wrd{print} "Niste prosli"\\
\tab \wrd{else}:\\
\tab \tab \wrd{if} \var{bodovi} $>$= 24:\\
\tab \tab \tab \wrd{print} "Prosli ste"\\
\tab \tab \wrd{else}:\\
\tab \tab \tab \wrd{print} "Niste prosli"\\
		\\
\fun{IspisiPoruku}( 5, 4, 4, "auto" )\\
\fun{IspisiPoruku}( 5, 4, 4, "motor" )
}

\subsection{Funkcije}

Funkcija je matematički pojam; postoje npr. linearne funkcije,
trigonometrijske funkcije, logaritamske funkcije, i tako dalje i
tako blize.

Na primjer, pretpostavimo da imamo funkciju $f(x)=2\cdot x-3$. Tada
je $f(4)=2\cdot 4-3=8-3=5$, a to znači da funkcija $f$ preslikava
broj 4 u broj 5, ili mogli bi reći da funkcija f za argument
4 vraća 5.

Funkcija se od gornjih potprograma razlikuje u tome što funkcija
ima povratnu vrijednost. Rezultat funkcije se moze ispisati,
pridruziti nekoj drugoj varijabli ili s njime računati. 

Primjer programa koji koristi funkciju:

\sourcee{
\wrd{def} \fun{Zbroji}( \var{a}, \var{b} ):\\
\tab \wrd{return} \var{a} + \var{b}\\
\\
\wrd{print} \fun{Zbroji}( 2, 3 )\\
\wrd{print} \fun{Zbroji}( -3, 3.5 )
}

Definicija funkcije je ista kao i definicija potprograma, jedino što
funkcija mora imati neku vrijednost koju vraća u glavni program. Kao
što vidimo ovdje ispisujemo "Zbroj( 2, 3 )", a ono što će
ispisati je upravo ona vrijednost koja se vraća pomoću naredbe
"return".

Ovdje je potrebno jedno malo objašnjenje: U stvari ne postoji razlika
između potprograma i funkcije. Funkcija \emph{mora} vraćati neku
vrijednost pomoću "return", ali čak i potprogram koji ne sadrzi
"return" vraća vrijednost "None", ali o tome malo više u
sljedećem poglavlju.

Evo primjer funkcije koja vraća zbroj svih brojeva manjih od nekog
zadanog:

\sourcee{
\wrd{def} \fun{ZbrojBrojeva}( \var{n} ):\\
\tab \var{x} = 0\\
\tab \wrd{for} \var{i} \wrd{in} \wrd{range}( \var{n} + 1 ):\\
\tab \tab \var{x} = \var{x} + \var{i}\\
\tab \wrd{return} \var{x}	\\
\\
\wrd{print} \fun{ZbrojBrojeva}( 5 )\\
\var{a} =  \fun{ZbrojBrojeva}( 10 )\\
\var{b} = \fun{ZbrojBrojeva}( 100 )\\
\wrd{print} \var{a} + \var{b} - 100
}

Kao što vidite, s vrijednošću koju funkcija vraća
mozemo računati ili tu vrijednost mozemo pridruziti
drugim varijablama.

Vratimo se sad primjeru s instruktorom voznje, taj se program pomoću funkcije
mogao napisati ovako:

\sourcee{
\wrd{def} \fun{IspisiPoruku}( \var{s1}, \var{s2}, \var{s3}, \var{za} ): \\
\tab \com{""" Vraca string s porukom je li polaznik koji je imao: \\
\tab  s1 tocno rjesen zadatak iz prve grupe, \\
\tab  s2 tocno rjesen zadatak iz druge grupe, \\
\tab  s3 tocno rjesen zadatak iz trece grupe \\
\tab ...prosao test.  \\
\tab Ako je varijabla 'za' jednaka "auto" onda se racuna kao za \\
\tab polaznika za dozvou za voznju automobila, inace \\
\tab za polaznika voznje s mopedom \\
\tab """} \\
\tab \var{bodovi} = \var{s1} + \var{s2} * 2 + \var{s3} * 3 \\
\tab \wrd{if} \var{za} == "auto": \\
\tab \tab \wrd{if} \var{bodovi} $>$= 26: \\
\tab \tab \tab \var{temp} = "Prosli ste" \\
\tab \tab \wrd{else}: \\
\tab \tab \tab \wrd{temp} = "Niste prosli" \\
\tab \wrd{else}: \\
\tab \tab \wrd{if} \var{bodovi} $>$= 24: \\
\tab \tab \tab \var{temp} = "Prosli ste" \\
\tab \tab \wrd{else}: \\
\tab \tab \tab \var{temp} = "Niste prosli" \\
\tab \wrd{return} \var{temp} \\
\tab \\
\wrd{print} \fun{IspisiPoruku}( 5, 4, 4, "auto" ) \\
\wrd{print} \fun{IspisiPoruku}( 5, 4, 4, "motor" ) 
}

Bitna razlika između ovog i prošle verzije ovog programa je u tome što je u
prošlom programu bilo dovoljno napisati npr. "IspisiPoruku( 5, 4, 4, 'motor' )" kao
komandu, a potprogram bi onda ispisao poruku. Sad potprogram samo vraća vijrednost
koju onda treba ispisati. 

\subsection{Ugrađene funkcije}

\dots

\subsection{Doseg varijabli}

\dots

\section{try}

\dots

\section{break i continue}

\dots

